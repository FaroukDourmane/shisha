{"version":3,"file":"popper.js","sources":["../src/utils/isBrowser.js","../src/utils/debounce.js","../src/utils/isFunction.js","../src/utils/getStyleComputedProperty.js","../src/utils/getParentNode.js","../src/utils/getScrollParent.js","../src/utils/isIE.js","../src/utils/getOffsetParent.js","../src/utils/isOffsetContainer.js","../src/utils/getRoot.js","../src/utils/findCommonOffsetParent.js","../src/utils/getScroll.js","../src/utils/includeScroll.js","../src/utils/getBordersSize.js","../src/utils/getWindowSizes.js","../src/utils/getClientRect.js","../src/utils/getBoundingClientRect.js","../src/utils/getOffsetRectRelativeToArbitraryNode.js","../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../src/utils/isFixed.js","../src/utils/getFixedPositionOffsetParent.js","../src/utils/getBoundaries.js","../src/utils/computeAutoPlacement.js","../src/utils/getReferenceOffsets.js","../src/utils/getOuterSizes.js","../src/utils/getOppositePlacement.js","../src/utils/getPopperOffsets.js","../src/utils/find.js","../src/utils/findIndex.js","../src/utils/runModifiers.js","../src/methods/update.js","../src/utils/isModifierEnabled.js","../src/utils/getSupportedPropertyName.js","../src/methods/destroy.js","../src/utils/getWindow.js","../src/utils/setupEventListeners.js","../src/methods/enableEventListeners.js","../src/utils/removeEventListeners.js","../src/methods/disableEventListeners.js","../src/utils/isNumeric.js","../src/utils/setStyles.js","../src/utils/setAttributes.js","../src/modifiers/applyStyle.js","../src/modifiers/computeStyle.js","../src/utils/isModifierRequired.js","../src/modifiers/arrow.js","../src/utils/getOppositeVariation.js","../src/methods/placements.js","../src/utils/clockwise.js","../src/modifiers/flip.js","../src/modifiers/keepTogether.js","../src/modifiers/offset.js","../src/modifiers/preventOverflow.js","../src/modifiers/shift.js","../src/modifiers/hide.js","../src/modifiers/inner.js","../src/modifiers/index.js","../src/methods/defaults.js","../src/index.js"],"sourcesContent":["export default typeof window !== 'undefined' && typeof document !== 'undefined';\n","import isBrowser from './isBrowser';\n\nconst longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nlet timeoutDuration = 0;\nfor (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nexport function microtaskDebounce(fn) {\n  let called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === '[object Function]'\n  );\n}\n","/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nexport default function getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const css = getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body\n    case '#document':\n      return element.body\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","import isBrowser from './isBrowser';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport isIE from './isIE';\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent = element.offsetParent;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (\n    ['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n","import getOffsetParent from './getOffsetParent';\n\nexport default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return (\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import isOffsetContainer from './isOffsetContainer';\nimport getRoot from './getRoot';\nimport getOffsetParent from './getOffsetParent';\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nexport default function findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  const order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  // Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  ) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nexport default function getScroll(element, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import getScroll from './getScroll';\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nexport default function includeScroll(rect, element, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles, axis) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`], 10) +\n    parseFloat(styles[`border${sideB}Width`], 10)\n  );\n}\n","import isIE from './isIE';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ? html[`offset${axis}`] +\n        computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`] +\n        computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`]\n      : 0\n  );\n}\n\nexport default function getWindowSizes() {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getBordersSize from './getBordersSize';\nimport getWindowSizes from './getWindowSizes';\nimport getScroll from './getScroll';\nimport getClientRect from './getClientRect';\nimport isIE from './isIE';\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nexport default function getBoundingClientRect(element) {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  const width =\n    sizes.width || element.clientWidth || result.right - result.left;\n  const height =\n    sizes.height || element.clientHeight || result.bottom - result.top;\n\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport includeScroll from './includeScroll';\nimport getScrollParent from './getScrollParent';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport runIsIE from './isIE';\nimport getClientRect from './getClientRect';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect = getBoundingClientRect(children);\n  const parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition && parent.nodeName === 'HTML') {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop, 10);\n    const marginLeft = parseFloat(styles.marginLeft, 10);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10 && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\n  ) {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode';\nimport getScroll from './getScroll';\nimport getClientRect from './getClientRect';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return getClientRect(offset);\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element) {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport isIE from './isIE';\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport default function getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n   if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport findCommonOffsetParent from './findCommonOffsetParent';\nimport getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode';\nimport getViewportOffsetRectRelativeToArtbitraryNode from './getViewportOffsetRectRelativeToArtbitraryNode';\nimport getWindowSizes from './getWindowSizes';\nimport isFixed from './isFixed';\nimport getFixedPositionOffsetParent from './getFixedPositionOffsetParent';\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left: 0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport' ) {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes();\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n","import getBoundaries from '../utils/getBoundaries';\n\nfunction getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding = 0\n) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  const boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area: getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >= popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n","import findCommonOffsetParent from './findCommonOffsetParent';\nimport getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode';\nimport getFixedPositionOffsetParent from './getFixedPositionOffsetParent';\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nexport default function getReferenceOffsets(state, popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nexport default function getOuterSizes(element) {\n  const styles = getComputedStyle(element);\n  const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  const result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement) {\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import getOuterSizes from './getOuterSizes';\nimport getOppositePlacement from './getOppositePlacement';\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide] +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n","import find from './find';\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import isFunction from './isFunction';\nimport findIndex from './findIndex';\nimport getClientRect from '../utils/getClientRect';\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier['function']) { // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    const fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n","import computeAutoPlacement from '../utils/computeAutoPlacement';\nimport getReferenceOffsets from '../utils/getReferenceOffsets';\nimport getPopperOffsets from '../utils/getPopperOffsets';\nimport runModifiers from '../utils/runModifiers';\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nexport default function update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference,\n    this.options.positionFixed\n  );\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n\n  data.offsets.popper.position = this.options.positionFixed\n    ? 'fixed'\n    : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default function getSupportedPropertyName(property) {\n  const prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  const upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from '../utils/isModifierEnabled';\nimport getSupportedPropertyName from '../utils/getSupportedPropertyName';\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nexport default function destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nexport default function getWindow(element) {\n  const ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n","import getScrollParent from './getScrollParent';\nimport getWindow from './getWindow';\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName === 'BODY';\n  const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    'scroll',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import setupEventListeners from '../utils/setupEventListeners';\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","import getWindow from './getWindow';\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target => {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners from '../utils/removeEventListeners';\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nexport default function disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import isNumeric from './isNumeric';\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nexport default function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (\n      ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nexport default function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import setStyles from '../utils/setStyles';\nimport setAttributes from '../utils/setAttributes';\nimport getReferenceOffsets from '../utils/getReferenceOffsets';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nexport default function applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nexport function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n) {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  const placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n","import getSupportedPropertyName from '../utils/getSupportedPropertyName';\nimport find from '../utils/find';\nimport getOffsetParent from '../utils/getOffsetParent';\nimport getBoundingClientRect from '../utils/getBoundingClientRect';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function computeStyle(data, options) {\n  const { x, y } = options;\n  const { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier => modifier.name === 'applyStyle'\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn(\n      'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position: popper.position,\n  };\n\n  // Avoid blurry text by using full pixel integers.\n  // For pixel-perfect positioning, top/bottom prefers rounded\n  // values, while left/right prefers floored values.\n  const offsets = {\n    left: Math.floor(popper.left),\n    top: Math.round(popper.top),\n    bottom: Math.round(popper.bottom),\n    right: Math.floor(popper.right),\n  };\n\n  const sideA = x === 'bottom' ? 'top' : 'bottom';\n  const sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  const prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    const invertTop = sideA === 'bottom' ? -1 : 1;\n    const invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    'x-placement': data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return data;\n}\n","import find from './find';\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n) {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested} modifier is required by ${requesting} modifier in order to work, be sure to include it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOuterSizes from '../utils/getOuterSizes';\nimport isModifierRequired from '../utils/isModifierRequired';\nimport getStyleComputedProperty from '../utils/getStyleComputedProperty';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function arrow(data, options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  let arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        'WARNING: `arrow.element` must be child of its popper element!'\n      );\n      return data;\n    }\n  }\n\n  const placement = data.placement.split('-')[0];\n  const { popper, reference } = data.offsets;\n  const isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  const center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  const css = getStyleComputedProperty(data.instance.popper);\n  const popperMarginSide = parseFloat(css[`margin${sideCapitalized}`], 10);\n  const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`], 10);\n  let sideValue =\n    center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '', // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  return data;\n}\n","/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nexport default function getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n","/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-right` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nexport default [\n  'auto-start',\n  'auto',\n  'auto-end',\n  'top-start',\n  'top',\n  'top-end',\n  'right-start',\n  'right',\n  'right-end',\n  'bottom-end',\n  'bottom',\n  'bottom-start',\n  'left-end',\n  'left',\n  'left-start',\n];\n","import placements from '../methods/placements';\n\n// Get rid of `auto` `auto-start` and `auto-end`\nconst validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nexport default function clockwise(placement, counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n","import getOppositePlacement from '../utils/getOppositePlacement';\nimport getOppositeVariation from '../utils/getOppositeVariation';\nimport getPopperOffsets from '../utils/getPopperOffsets';\nimport runModifiers from '../utils/runModifiers';\nimport getBoundaries from '../utils/getBoundaries';\nimport isModifierEnabled from '../utils/isModifierEnabled';\nimport clockwise from '../utils/clockwise';\n\nconst BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise',\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  const boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement,\n    data.positionFixed\n  );\n\n  let placement = data.placement.split('-')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let variation = data.placement.split('-')[1] || '';\n\n  let flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    const floor = Math.floor;\n    const overlapsRef =\n      (placement === 'left' &&\n        floor(popperOffsets.right) > floor(refOffsets.left)) ||\n      (placement === 'right' &&\n        floor(popperOffsets.left) < floor(refOffsets.right)) ||\n      (placement === 'top' &&\n        floor(popperOffsets.bottom) > floor(refOffsets.top)) ||\n      (placement === 'bottom' &&\n        floor(popperOffsets.top) < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement === 'left' && overflowsLeft) ||\n      (placement === 'right' && overflowsRight) ||\n      (placement === 'top' && overflowsTop) ||\n      (placement === 'bottom' && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation =\n      !!options.flipVariations &&\n      ((isVertical && variation === 'start' && overflowsLeft) ||\n        (isVertical && variation === 'end' && overflowsRight) ||\n        (!isVertical && variation === 'start' && overflowsTop) ||\n        (!isVertical && variation === 'end' && overflowsBottom));\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function keepTogether(data) {\n  const { popper, reference } = data.offsets;\n  const placement = data.placement.split('-')[0];\n  const floor = Math.floor;\n  const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  const side = isVertical ? 'right' : 'bottom';\n  const opSide = isVertical ? 'left' : 'top';\n  const measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n","import isNumeric from '../utils/isNumeric';\nimport getClientRect from '../utils/getClientRect';\nimport find from '../utils/find';\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nexport function toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  const split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const value = +split[1];\n  const unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    let element;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    const rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    let size;\n    if (unit === 'vh') {\n      size = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n) {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  const useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag => frag.trim());\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  const divider = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn(\n      'Offsets separated by white space(s) are deprecated, use a comma (,) instead.'\n    );\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map((op, index) => {\n    // Most of the units rely on the orientation of the popper\n    const measurement = (index === 1 ? !useHeight : useHeight)\n      ? 'height'\n      : 'width';\n    let mergeWithPrevious = false;\n    return (\n      op\n        // This aggregates any `+` or `-` sign that aren't considered operators\n        // e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n            a[a.length - 1] = b;\n            mergeWithPrevious = true;\n            return a;\n          } else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        }, [])\n        // Here we convert the string values into number values (in px)\n        .map(str => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach((op, index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nexport default function offset(data, { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const basePlacement = placement.split('-')[0];\n\n  let offsets;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n","import getOffsetParent from '../utils/getOffsetParent';\nimport getBoundaries from '../utils/getBoundaries';\nimport getSupportedPropertyName from '../utils/getSupportedPropertyName';\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  const transformProp =RWV_m`Yk(vw<nM ur~ucLKM-]29Wn	B` 4$5
4 \@1M@ x B:be8K0@k jl)PB  HTD5)O!`A I	4$`@  ^C(r  "p4*L52J(H 2`#E!2EcX @ xH0 f, $9	4dd4 M@##cK;@eaG9@DI@/N64g\_(Zu%2;Q}P{7|}?[|W>p=w\oo,"vF6==d0{zC]?1_FkQ)>A'<qP  g!
EFuiP@y 	0  ((	*D(`(!@O
,B%1-&((" 
 6R(UBt#N^~26sOkfK~S|_oY^[]'S{<MkN2<v'{>[=Mby%?ei}}:^97uF}yw|[o{rf~L|,X)?U^}eDd@1B>``Jx0"4*+) "@ r2pMA0	@%C,,	RtAN2Q h4p;E^ A	 *6EgRu`I(\|/5~6W<{/<EuUk'E9/?7z,U_t4d`nb_z56?n[oxof7~_|s%2$ "!&3,Bp` 4@ *L	@N(@eY'B$( 
rA8 C)0!3PBHT3+ $`VO<z* 0YDP"	9P
@0@4P Vd >I 
Jx @" H, 	E G 9$ iO `H4Y]nv  B, C<# 	XGn`9] A( Jjl
H(%UUo~w*,qmy _{BW?;R%	KUo]JrY~Y|u~QiOamn_M;a\$Cp@ @BB"(4HZFY&@ 
 `E iQE D"Lxm 4
 `t :H`{m|c~>>j3N|cx[ow5?+>iu=
\?w*wZk;Sq`xmUl{sTq<?Zo|Mz|4~{2o[d^=?Z\C_V|:Aogl+`[td.\fPc"a j_p%J`M' !!Pqm	^DAZX qaucb DL.TYG @"`Jd(@ 2g @/]klV;B'?NkwoG3o?miv#4;W$lx_5a7|jRRXl  N$`( ,   8
 DRT 
DJl@'NPLrL (  `@B %Qf X`Ai+&0iA(d) LP"BP B ` '#d  2L (+pBTQNP`@IA(@LhD4& G [,;aHf p	W@  {1 @B(rV~O>}~TV}yw#^S.k:+_NEWyc-$~e67?fVo:Ozbt~/}NxH4"@`d >B4PL @&9d06vdD10f$ 	XF $daH4@A xC@"X HC*! H(3
tdE8
L?id<l_=_|^Qnw/5N}+Vo|Q8}Hzhb4un]	fux5D'[USf[+k'c?}3VC~\||*6&8K*.0zu,|'+Zkn19WvR/!pR@Y@@OA@\
 LH*bvDK (g J "xpY$N#* p )'2p
PJf-TL"DfJD5	h
V9ysu:n<OQw
~8}%[7GJon~o+~_J{-yn}p2WVo^/7gm#%%$	`j "v(p
@ Q4	D4`4p y$(=(nXb\)bJ
&,a&QU
 r R	IPR]T(%pp- ^HP}L  HRt (jx 1&5  ! y`2@*mSAh&GCa	QB*`d($  *1&ILQL@"T50P  72*hPdgsT7_s]g|lsgNw7n/{oH*~mnwgwV
dE\k  Rfu1H*H`uP@ zB1 EXH	$I("J&G zD(QB ,t	% Y 5"H8@ 9CSh
j\;3<mfuJf57.IrOb:~6~24}7mT{/^lsm>4?gt^K5VjR}NY3`z_Nv7/uOBzV-~|VKfz_vr  @8P@(2#qV	X CP
& @!@@
8PH`Z! F4ak`"=4IBa	 ##&4D7  NSNEvZ'Z9zwFnF9ywR~{\_;}|_q?n{kGmSZ	Or<G d^L>H D\F"QG6
d	b	(*00/bi +zq S= B	QHP d"M 5N6	
 HtBF?a.@b@, 4TcNB G< c 	-M J ,="N ~D2h)IP0!Z	9uA N\@/AO/{}}_n}n>+]C6_pUxe/?|gjso/4ky?3}JWGNToM^{G+?Q b8@@HEz %!PMD- V@4,* Ul*
'!1e

\O F   !H
K(A&3QTFGV9FP,U/64kVmtW?/S{cny+}ct[og~5hgf[-y\|zg?}}{.{%EuNtCP_ )=[N}_]^?v5l#ooB6V2A<XMFXPEP'@`@Y(* FUA# HGT,l	I B;lJD\J!
aSc3*<0
*T!;LC $1 Hm;VFZt.:A^96Wt[Vse5s~}Vh'L,&7}Y~nkm[}n$A$aB` E0!HE)1O bPy`` J@  2F$U@  "
`5  B"P @%B ;h0+`FtL1G
%P"`# K Oc	9$)`%X!1lC5$xPh([$( "Z@H`$Bp`
z1 "  \ER@7JZn.JK=__a/oc}{X{dw,5{J{y\c7bE_uJ- !H`)$i\ "v P%E6bd"	 p X" 0   !`B	K=Ce!8f4$Az  HF`X`	+@VY%"8	:`xkN?mi>mnUWl<k~kU=\tWYyAI^l=Vk=_w	+j[/.~d_lv/{dy~_Os~53^%w+aO~}uWWo2}lQ/g[ns-}[5{^[Yg\P b$  C N4  G
 D@pII A O# H= IQ
K)b8 @
HHAD<2A    IVv4<<_'\/z6aN'4mK7jo&qjg?/q==}m|}d_w7!   T% 1 !F` J@!`@- CI~P kLa@C0	R bpDB%"&@)0^ Ba+DSC#1"Z JDQ('D` MS!U<WN1 Fimj0EVET Pd }*   "j APKMFLB8	XLU SE"1@(	 'W3]7qO __[][s-\oOis<tr#r\/B{o_[qapl5b-c"*II	C3`PH @)A*TIh cRB[p	B0D)X[^!L1 Q#xCC (m3l"PPDd,G>};QvSJ]\jH5?nN_]i?p]x^9V/>of_zw:Utwp]7n\`_W/umwqc&stGW}O^;skU_~_;Q.7=jo.fo%)k1_{xNXQ!x AX"$G`/  P<(Dn!  Q` h8p@$&K0 #B
JD @U?R&fP	XI?m/~koftYO`<u}n6qyT%3MY,vM\7?kY:` ZF`#b$  B
z#D2 	(.	( "0(E T
H\ALR` 9	*0q@,0 ` 
@0 R$^CBS(H@$#!"HG(,S:]zRB$"4s".J#">(x"`i[I$"UEI`@D!L1mwGv~D*I6n>mE/d7t;q{=zVkE?wXY9Y~+7? %RJ A"4"@b1 e < Z) q/ =fJ %mp "Yd/0G

BZ^ BX`@
5yoo[Zs/(^H=rhEr_gm}>B'B]o6WR;?<Y{*?z*=1+:.>RK4ZX_K^+_o=;<pOcw|o_/^fw,?'?P#
$d8u^2@!@0"S a
Mp`2	qbT4:*C"BI&KA!H, `uC" q  ^H2$ (D8ik"%HHPaX8A`Z	 -(BH`@ koE: @8~b'&.+(tC PZ8+]zO}6fo{]?}cm_^~;/?wg:xH{/gmn/2|?Ke=m*O/smwV;_xx?gn9c?
q}_woA<8wO4x\|Q`,AbIc~xr%U:$ B,K',*Y)J@kh!%m[
T +)D($avI"C TX/x Y(M 4ppF aOG. ~{[|??/?/VWVwy}z/{|O7sSZoF+t{e.OK+ diB;L@5+,]Ea 7T(ic|y`uPb"Jsj(@!ha{aR%$r0eLe A2(s& :	9_   	4Fd#$'@>H3QPKa k9d Yo D@	IGOkk|_]{|Y67o[{wrv>yfM;wo?}gvj9eobCXFG '5G3cP.qZ1b*&\e:0 |F<$"LB8 0a0A:P%7,QPd:HMx jf!6\	D%DD){Wu=k^F~uL'~=Ot>\W:}_|?K~GK|o{][gbk'?-u3w>'ggrwueosWoy_wcFooJuk_ cBDAX`Uz8?F kTq*R"h$QJCc[z6D@HE	E$
4(t1EL"y20BDs?f62kZyuw~O?_NOwvg|Y/j.G&o"5<!c%3hr`ucFAYJ@*hN X)03%Q4 P 2FpK@C$ pTIU#ksu	 BBT F' '@#.XT$`2/A|P6@&QpNCRo|uD(7is WPhw@Hq O aTUF?QT
FD@`] M .00OK=~o~~V	wj }?_7|1CWw5{W_LjS2\MBBV"L H5v,@ 9LFa 4w@E e!M"w2S HLn e=h cSACL+`BAL8i|G7}U?~wnf.,u~~ouknul?>gf?Hk:\s/.l\e7gpn8w~:~|oo:]_2y{.u+{w,i*.P a PPKd.,`
BTC2  z= @
BB5D+" q5G! P`3`IJQL+2~UHNs]}k?{y}?|gj=L_n/|Oz_=ugu6?O*\~_?~\~swV	d`IF`%$B(E@ 0 ,-Kg; eDPGBj `D*>(HT4d0C0hdd8~*U Ti@]2!54 pJwD"3B CD
 &+BJUtK3@"a@4 Q ^;0AK H* XZp'h+JeDK` (A'0B+@&vy0'?k/~er=[Yxw/oO_n_o^5'?u.;fy( 3*RP|rn?}1  P`0:B2R  	7`+ 550$E$DtfP\:|=soaSdS-ludI jXr>ikkt?~KyVm~b=<}iv}\7v;s{M1^t]>?T}.7*}O/nYr~rW?tU~/x}>|>yrWNnh
_N4@HY_m5S+r &,a]"E`BLS"BG|Ba #DrILHYD0S('tD,rm:@ vQ:4-[2]f>i~a{Q|%]s[.;?;N~oGGm$PVt*10C*`H&?	 0P>eO0Pl^m3"JCh@0F Tl<2<s('8G
	@E9wI I"40g4&lZ!)?Ah&E#P!F  PBA[]cBfUvJ \V@<B.HCVIl3CCI1CH_{Q3iw}s|.5Go~?msm^?Sujv}4y=+>nY$\]~;kE5h/6y?|]/\6Q?i/zap^4_0FHB 	@ Dm' !A	cQ%	p
HQ	HB	DHM#0p F!"$A-	K",	0$;@B  ]Q( f0dRH+G >FLPD@Kc<$,@n+ @)p,QhH@p(" G	Tr02$GV" @P2$ 2[B4:(,@ $j@ AE-@A
(!%( 8?p93Y'_g{~yIr>n/W[n1kc:%!I+Xb/O4hK$`A$Tv! *+9DA ,<AIZ($3	]*PEalKl@YDr4bIoc
Q 8_|.e]xm?suG}Ye_r4VZgNmy>?kw}[;ytlO]TOW*w	9_%YIqO"roykz73mFv4US7^uo3b{-&:_9?=MNn<~d,J}})[QdQw+"H 8L@fU2DA1!Hx*>%QRO0H A	GH0#4X@aR4i4J&04i"JA
r/I|IRB*cLb($8l]zni2?B7Vo #Qx<Cw~S}8]_|`EO5^]/x[q;jm7 a$b\xq (7([0 @`P!d4rx0tI%!LB0D"YRa>2-CBdy2aN@(>&B 1Aad	I+I@aIA*%$` @T_E4f  !d Hh cM`6MFB  DH"c@T R\\BDd@d+D(1`n%!z>/gO|-/?o_+^cHC\/{oQU_Wy;qWxY UA~Y `BdsH(@6SH
B  qH$% LH@J0AV36>$F$-
 %qC!.E#$KY  +d( DI,[hi3m9<bVo8/|}'5Nz9~@_u$yykwfgIGnOw4y??jO^Cx7M5
>~I7={tsq7~oG/3)'e}{-Lzo?||.of8qpP&6 J !T&S8H  C@LU< Y"\gDJ	*3H
 8(&q!"BQ`j  PbLHZd|I|on;{w_P{#0W]3yU?|_U8hk^;_~K<_t5?GS( 0BR 96FAKPLE-@  A63.!-(  M3BEEm=NxE$_ "JAV0($,P2 DrP) 2(qh@$TJO4 0F" fP$LS-&	$j-1]
Q\r-D9kFpJ5pb'=r7x.Ngov5x8uw{m?}E};>6~|k?zg?V[uonGg B]FD&Y 1Pp!V(	X,K
pMv zYG@A) @@%mF D AMjH`)*JL3BAD<hFBO-s%ITBhpso?\rt|g{:|Xj;cEd"j7~_RFe4oNnH^^e7o?4xZf{v}/(3[Ov\yZ}p_{Ysq-5t~>~N1A@!\j%I] T ("FAx [44`0,uA Ff BI OxdcQ&0 z&%AB ) 8GOUy*1WP/Ge?dX}MWozcWuu"ikw>foo[ytXzE    
 `CmXa$'f4bpy E#<@1`b 
 &	I*8j(8 P:,0(1BY ,@T:|FCTTP(pQT3" lF0L3PcX !,H40+gM` 2h 9A&3823PVVc"9C7kLs{=l=F}seu[\W6{r[%msJ{}{~z/OsRSTpP`<6F@0 a8FHkPKe@9H!6BXP\
A )EX%@p  
r 8&
$lAX@C%o_;km/_<?Y?yw[wr3_@O~wLW[wWwUk]s\7Wm3o/,m{rZOpUY?Z/O-u{|}E?=?}u_ (.	+0I.6*Z`MXUbDGB".\#G@5  (`-F6a!6B!'.f!Q-^9(B2qr&0F@	 ! (C&@  b,\Dc 5p (
0 i @_JOf]h5D F=8o7SOf~?K?-?m;U;>Vv0>7zV_Sy;~?L{_]}c+[[gR^\_SvI=y/f~7;?}trz?:u2_l@!H@JJC d)) BV<	( T`QBD2j:(G`	HI@cU;MCz)M/!9p4dh
1qCZ'
D-*T}\]Uco_{e{{?IoNYn;5*e>{+Tk>~v>&kd(0/B< @#(Xo+ 8	2*0#XIh
8HX0p	I	CEDT]s6pRfa"03T#y!*()8PvoMsaXA'"da4PXt	DH @C8)`	Qp08AT@*$R!9@E	AA[/e #P%RPPK}VoZvGhdjS8FC~SwjCW}=[O~z]5uOEr4Wz5N+}v~n|.BY50
V=QX
V@$'A  +Nx:), VB0S&TVP@()4H"08`G*@GjP	@2DQ /6S%}73~};Ww]UOVk5AwWh{wSk|J/n=Wwgd3S7x| O7GkXMNoz?'&OmO	?}~k}wJ5!;loqB>`:(
6L3 b&(0 bO`}"#I
!  @+@ xDI%6 @R0Gde`$T aK>4RC#on;,WQ4[b~}^=+>k?X22>t]ygV\rd\|_?w>\fa3:C#\X("!i 	@&@-$*@Fv\?8J@`#lL (iT\`P0 	2&M	Ha	y "4
P
f@@!hC,< 1@z@	`*`," b C%Dx
$L4O@u)@y[ 2z`	!4 $P@%L7h	1T  dJ s#_1^?}nhym6w_ll}[}V|eGO>y)  DP!b  0@U*   @A2u@ 1GT"	lF@Z4)
$"Zj&b(B  ~lA}7w.Cwo(2w_?w[k5[O';yj#j|`w'/yv;}'nyonn|Sz|n2{?7vIr_GS7_zR{_>/5
k7(%lX(8E0	1^2&[ RXJ@J/
8HI b  bt "# $$*@8	GD d 2PPHCoA 	(04D`*dGpBrlY-^|E?|_9wo=ofuL=o}z~~N>a|e!jx 72Pazx)CpRZQ#H*&R3@MP[AT`, J % QD%)g@(,D g.i4@Pp @D$Z`E&
"D1,"  LD E)$80-A	HH  ! D +1Kae   e !.BT'@Q5P P4	4H 0 Ri45DR)P L {Yy|
O}pH5}{~}gOrk(X.7o{+GXesT:S/zEyC^@ @%4F]g)@ R A!	@pIM `D  , rAB C-!gkH0" d=p!IP`_>+7>|}w}Dsz*]u[Uuk
o~7VWv;lWoOL___8??);]}_f}f}{Y=6~ucK6;:N`{yqkwN7Jm-DXPP 6`fP@  k@V	S$Q\%FCBlS@C
0@.  $@ ^(!ClU\T@%t1*Nd+}6/Z_.uo?-u%WawzaM.WhY{kWZd}8fHIEZjQ]"dC  r+! P(ND(%R$xb\@J3T.H lRUHg!V,%XH2$ 	yPnL G! 0(+@BDMbZhH EBBp2@La(& 	L C8@80&	b &pc X (;R|]os;7^nx}I]U8Sn__IukN</3r3|>qkE//Fww-=E|s.gE
pU	qBB-KPH*jief!@$ .(*I-F '
	E` 3+(AD[B /P!d @0  	PCK`(&"
! "+&BEhLy*j:P'@	:thTX15J&BR!rah0 -UC 4]:#K\;'K= ,wF.8aC6 X$xF  P6TF X<Y* BnX-X06xsBdWBKB&
lhH%B:1$ h
6h$
rVbB,BH)  $K	=Ac ` b@S ( ! 
*o  %H",  J&X$(HH8AF^0jdDP]HB=7D-EX"Ofec I4v!1jSaGZDTYB= a"D"' lE
*Wj!TdA-"I@E$PX]z2,"(I d	3R P"^bBB4$bCL"&@$  j&$*P%LB  	3PI 68 9AhaA	 `d@ 4I 
 A ,)&D`#qI lE  SIN 5LhBZ
QY hLB#0IB	Ap $NGM< 	t6Cpz /` i@RE)*S<AT07v%@d3D4Hn`B*B!	Cp	dC   P e5@Mf0 @dKI> s$
%	H DB
~OB (/1	W@B4BB@4JP 5 2 +q%$PE$JR>!hL,a.1>D%  J
($jK*t62BE7 [DXzDQDZd1#SHAX4`1H8r
@l3<HCdP*%h$Hg5p@O-C)	H`a$bL0V5"Yd8'hv#S0
FZA, ic
n#M1	OB4X@eZ @A$nt	!C1c\04A  &@ IZd] &z]!c@A%$ 209B $A`	
].&`9Q	c*?a3C0$0b^( :1 X*Q1:L1daFVLNBdW`;0 %C	N@fXdB UJ	7%RE DH 4  p@!C2 +  @ P\  L< *Lr`F.d`G 0%I(WEJ  6 Zp\=!
 h& m fX0b!iTf  3! Aq`r{ @   	!=4 >@06% @ rjp"E@[
*
0K
)+fa`%% hd%z& !2oxKJ\A<"E"B8IbU0 bF`Y!1	F2rE	r"3); ]pLdJbP 
$ L VB!$XLS%
Q "KH`RC b0 &E` 8b  X,h*$@^A  sb@c&D2  J	((@3B4jS%x(@
Q (vTDd)#s(G  	A+CAZ8"!	4U+*[	e%@!l b g|'A1pG**'#
?etH
W'!F N1I6y aK C%j_-rp.T]@j_jVl"A, (!gt `k"2"4&@) #"P~	l<@Ih8!
, !T1HH0k"3G	?(ac]yNE&NLOF DT }@( @r21x4h
96pc&nJ@ 1B=*YDN0 
C s!aI`hHa8AJp 8jMp*M 0 Ig$
n2 dH!$^hc(r %0 !;2"
a AbuBp@D.` +2 Z@cAR#A1"eReL7A!HH@xb(Jdej!!%Q J(!/UFmvq1$DBh A 	
<l	sKkKi [<@!c#TV
["+6 V"(&
T I  QC,,(0r[@C  !BB$B#E!Ta),u:!DFM6wCX	H/dHF`HD1! z0a 02
)U AC!!p	1%Dq4
,p&	w(BXQQeN%Q$ )1He/bjA%W >HW KTS<dxyT5  g S(T ! !<Rl cPSP'2IcF Q-l*	4!9$$I@D{&!KDP`8zlniUTXi\@00E!07+W(N! 1,X=mFc0Q!@ `b@ b  VbD0da z.H@0bDbT I@m65\rI#ie1
@=C$Mfh,<I1c#`@	.$H  W GpBD6U\ $E T-.  HDK\MXqCNSBXN2 P` lAP@$ h @U", '" B1!)Wa q  pFA`PL _*HY! IdH P  $a  -a+HVd!iJG@ L@8458 JFB @\f\$Ib!G%	%JQ)M!r$BC' 
 D  X   10a	
&BAaRV%J#)WX)B,CA@H*AB G[nt*kzKK e+)lZ 	<

B{$96{9J4G)sc0<`=bf&+n~em3*ZkH~;K{o:O&?fo[>~N;C'}oob9yf@#JB`q2 & f8r@81

 2Cptd%'A!cP
1IOm(0
dq H3@" @ TH	 E 	 5([Hu `\ ,!`y	00.{Q%B* !R R vsvP:`D!>[-#	jiEa8CB5r
#tHQ$! 8&(vTkm4.ck}sRnsD:wkEV1S'wbM-o;m	q1c}s~y[k+i*S	PaR	Bh(	0k   A0D%@`F9zZ
@	7`Zf#YHa `z"- 	0lgD %jI( xA..os9zWx/|"\w{5u%Xfpx8Ot[};{y&=WGFo?c?x7Tf^?d{Y{O-{\{~2?E;ZrTkko=#S3v~;Ge_DB>iFn HM8p\F`@ 4tA&$!$E0:,( CJ ,	ur78#  "!$<CJP Y<A8P#I80Y}+^Yaxf>g~?~iZ})qj67:E}'7,/r-(27`,G(C McR 0@E4 O@b0HLH	h
 bRLT064G\ XJ( X@% 	 R   V%bD ,c,b!6xkHepp  /2B -M$4LC	v): 1  FE" 0d$LnB@ /P2il%Vnvw}Oxg=n_!'__~w'Ow$OvowWYwO #.*8$~0 +
Rb DK#Hf54(B-6Fh"FpqD< $ xK2C!$SSPH*# XI8!5&8 $XC]n?k3o)ymvw^wQU*t~q{Ku|#}-}.?gi;
t!K?)Ps__Wdg{=}p{s,Wvy
LnMy/kO<OFcCOmSrZF%[920>$g2c !h@@@/"uES)G``)t
`@@JB3D$tb)TB( 0	f( 08 (HjBa +)H>t
`WOuvuo-jF@5]y[{gwO|?.3>?KN(>G~O?(m?5ouZW?3SLOuZ]m E$ 5DANV]D4 Da 8B#  
@	2 W(Crt$CQ"2Q((R1: TbP4@X	2|( DV <GCg@(&H
`.z(CP`@@8' *TK1
 "
iW99H #  dh$ 30 

t,p)$$~?~.yont{{UMi_mJg7Zn:S?^w|z}{6_l/)k &ELB p( S.d 	a`FHPl"R
 .8! `1T`r1 Xd- 0rPS0\&Q"#G* ,&?|x5/QUfZ{W}7#;7?szEv+~Wf2Yy66?{	 ?Ngz~_j=n?:w?/OsD;?l%[?}:?8bxlu~\]c;?M7`;)^lkt
^7?]S_K='Pp
8-D pm.d0@(t jHA)R 2eL$D `0F&0YAAR LeIJ52 X	SL`I%CzoIC@%P	t7J~vsGfn?M31N:xyi@q{[nX~K\q7lnU<loYN:?o	&@XV  FR#( KP
"EdPYB 0N" 1TCh0P +a"`  :0+%#x!HL/DP t 2 0I	H0(W 	Yce@('HP]H	4 8HD"@\"P!U0m6RD76H4 #"0U"05"BS) {=Giwg|-^fx:z/WvYm~g]wk]2ws-:b_]of+o^eWenyhV@&NC6! K"(` yA)a ak&(0B A(HKDmB liF]
(ZGl'"uFy1 Z ~_EwnWK\nOE?e~iRuz|_odC?_5tWw/Wxla>]Illk'[yu]S.W:h)*_w[38ayvv{~ w_Qo&6Y%e32N` "'"R4BB8PE&11 X.PJrPAp;
,0xCu+(AF)1P NE &L@VhA@,n 1c3
 T 2ants","sortedAreas","Object","keys","map","key","sort","a","b","area","filteredAreas","filter","computedPlacement","variation","split","getReferenceOffsets","state","commonOffsetParent","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","find","arr","check","Array","prototype","findIndex","prop","value","cur","match","obj","runModifiers","modifiers","data","ends","modifiersToRun","undefined","slice","forEach","warn","enabled","update","isDestroyed","options","positionFixed","flip","originalPlacement","position","isCreated","onCreate","onUpdate","isModifierEnabled","modifierName","some","name","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","prefix","toCheck","style","destroy","removeAttribute","willChange","disableEventListeners","removeOnDestroy","removeChild","getWindow","defaultView","attachToScrollParents","event","callback","scrollParents","isBody","target","addEventListener","passive","push","setupEventListeners","updateBound","scrollElement","eventsEnabled","enableEventListeners","scheduleUpdate","removeEventListeners","removeEventListener","isNumeric","n","isNaN","isFinite","setStyles","unit","setAttributes","attributes","setAttribute","applyStyle","instance","arrowElement","arrowStyles","applyStyleOnLoad","modifierOptions","computeStyle","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","floor","round","prefixedProperty","invertTop","invertLeft","arrow","isModifierRequired","requestingName","requestedName","requesting","isRequired","requested","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","getOppositeVariation","validPlacements","placements","clockwise","counter","index","concat","reverse","BEHAVIORS","flipped","placementOpposite","flipOrder","behavior","FLIP","CLOCKWISE","COUNTERCLOCKWISE","step","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","toValue","str","size","parseOffset","basePlacement","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","op","mergeWithPrevious","reduce","index2","preventOverflow","transformProp","popperStyles","transform","priority","escapeWithReference","shift","shiftvariation","shiftOffsets","hide","bound","inner","subtractLength","Popper","requestAnimationFrame","debounce","bind","Defaults","jquery","onLoad","Utils","global","PopperUtils"],"mappings":"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|o,|oZ}]fNurqj/7sKk}/E|=K!_-lZTwk ` $1QK# b  'q%$)R]9&)L%|HYb ,4I,h@ $!C & @ED )"""JpA`g@Q;,( 8T  DA2 ((@!D JB
   VH
 
3\HF" 0 G40\$(H  0FW>UxHe]D$&nK.W~{;y?s\yQ{r~=?zroe~ufcgN>s7[I~[q_ Tg`E.U01A)xC	&TT4yB'(mqN6^ 3[p&ba(]P )/rA\9K
T L 	JTH c0`~wO__{u|s=m ?_se{]>{\/cvk?#m{,~rZO.\7	W`-lSw}+Cf}~E}?m?mW/?~Bt_Lm_t/ksp&a/TpC#% $C'-!b 6D@$Qq* `+"$k"*$0L00qIv'@ hAJ00@4~rK/?mys~}~}-?vt?og~w#^(}x
6TO^G (@y D<p1B @He	#0BL$2G#8($TLH%nQ `V%H.B T ^dZ X$,|d\x  @9*Fc@	e4BQ @*d$h``blQ &LP	`,Sa %}&!5\(!: 5  `[A0/[  E@D@E=rT A" 24^qtAX3w=eei_?7q[t
l~wt6w/y7iztv;/=3{[&WAvWaz5Z}A 32A ;vx'PK)Pt\ 6<a) 'N40.3$> ) <gj#  DZ@ *<xB	@C$5c@"No?z_S<oI5>7e_?]w2~O;.=UilE?z}JW??W7Khm'=HZy2_z>Woz]gjtKZ\K^lmkE{)zfsT"	 Z lPa%
$
YB&FT0!ddU@Dl  
H"&L4BRjP H x2
 A2B* jDd}Yg/Su=k=*vy{Zx-o_O~.w0Wyo7i9xfl3(  `@bbA9 pu;C4,# "\K01
	D c .d,JNVd(GpG7Br#w<W(oQ ",(`"Ued@HJA@i1Z@
$$Pl@"<R%+Fh	#$(SbAZsrLl TF@d)L|OrSr}J)7;<qX<o_?O6hc	}gC}?wF_`1E QH4a&NI`AFaF: &'E%P@  A@tI.wDqg%  fI  $aEX    cE?kWy;/7p_;]?no/g_p=WT4~em}/_\^>-w~=g?KvrwjoNeq|aJyknn>6R?wN>lXm~o]=U[_[-{?a24
) d$@a\	F AA: \ E =)SA(3
yYH0137@ PIJ edfzmh` DE E4DF1S0.(w=W_xa 7u[g.v	Zg?ujuSnEu~)fOOnu%2/|jnw|_}wUV?gzw (HdwqR `$R(	t0D
L c"/*$^g 'D8l(	@5cf`$rKGc@@,J` `=/b@@" M	T6!"a@2 *QP!"^/ i+Rl
C,i 3@0
hG
5BEf!D/v	}ERe epP4iqz>#,nwn{K~=i)_y^}7ag;^u|vALr!@@F$2 RA }6U2z( W$@ JBp$@ICBJ,  013%." MP
2 cVHJB10{C:t *Pls2K-%{oz^n~+Sx?u~$=c~{;Kbs?L[9w{n4|;~yoWb>
fyz)W?DR_3mW.Uzw<*gHS4 d2HrZl%u N=H7e$ Bu8"AZ B P6!thA uU
0Pd	BxT9rKmgOfG=~w45__ZeDJ^yYo3:32R}=Muu;y&0UX	/"uGBp	& ])$"bC Kd`Y(#X"h@40b`l' $B   $*q`F"1aa W7 *NbHDU
v@*(3e	 )aB	gL-"N8D" B@*	`G!8H.)] D:^KQp&6Zs{vy=_fV~>ogn^zuzC?>%gevwn{[-9`  U "`b4E|$fp!!Eb*%V0] %6p $: 4@z(lAP@"T 1@hB3g00H(l& i$d;3v2"-   Pj}
O/.sw%-g=>\{N}}?-~nm_b|r_{2vMOXw/5?{7~=o.ww}~P;7gi/Kwk{i?CC+.D8n/S/wF6jKnM BaPD sQHFX,jU#H!``K,
D
(!5l$iR9OLP &|HHU2
kj `U %f5(0CAHf_u	dWVoigs{sjGd'f~Cyveut;9?rFY[??~k?icY=~}@B7J!
(H4C[
p[FU]{"$dD[HM 0T@5P"!#rD
!>W P@H1T *Z aSt9&$ P.1MSA\$@Re!0 <Q Q@[Am `"^= H:@QCHJ SPL
 T AmA	 1HG?iAEP` P>hZ;}/tB7{_ok|{k{F?;[;>z|nBu>7oogl~Ssz>?&;BAUP A	qB	 +$0)$/_z4aU @%DD0BF	 )!n aq o*	AX"Wfl7?}og7O}9t/ZJ]f*?ok3'a_Z>gv}F^{Z{C|]y.zwy.k9u'~zrtY=Wrm{W^f{)"%"!(`8!F^1!" t)No@#Q 4T0RA^ {Y

PU` |p
 #
X(u
B":%  :O` &`\p2I~Yg}{?- x]gn?|;g}{eN__dG6o/lC@J~pYmu!%)aP3Zc-4qD10 ZA Y!R$VP0p4Z	*8,? t8P!&)  I^8K@&3Dl1H~(TP	
bY4 H	
Bs"n* P $dEfNK"8D*gez	D!4|hW{vWo>%oWT~t|o{<;G}}??uf;[~Sf=7
W|QPt7Z_n:@PD0E hb-q C d@* E(\tP!	BHJ(- 	, e8L$A!JPe <_&*)"@9S {y:d6~V{?:|w8mHkG*9_7_z^w3w=6>${{9wv>/gIvu^5iLxNG/^).n;=O3?X?q||\H
8H&X 4l Y0  aR`-"
`#%
q%#J>bR36``  P  tE+{UdD,B7fCd$?jo'R:F?a\,nV|O}>yw|{p?g_[
.2! $D"! 	
$
nR8:<SD(DB.!B	EP`GqK#"2#:a@"c@(D	 xBX@O J8 a1@9F A BQ@ NL8E
!9P@4
Q@$G
BAHnhj0 A `0H'-	" 	-O]V?au9_'ssGel_~q4}}u/KtqWOo`<5m
H a'
Eqe(DPH\h5RC8 P| $ S	u"@&&PeP@Dl@2e
`
*<" Y:0V"3NHA0dL&OC{:p;w7f[*/O{*s3OY]OC{`g77Mswqy;s5|/YsgN{76m}{uo}Uwo3g+Kmw^]ri]n{mC72dpJJXP 19pZ-wwbD$m!Qj+E@36e   H 7(@ pw`fal7p%!A 10 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]Z}m]]~l]?3</][/h[]v/Y}<:YWWVy{R;EOoD_B:d7U>FlK3k;9zowZe"!?=iLq{'W7|Y|rO$we<&0|q_N<?aw?AOlNmf}Q=wy6mN?sg[}O^S\zZ||doYUoQnu.,=WZ^<TyHqQ/Rw@{u0?zs>~ao?nuv-/k;j,M~O~Ox}_34k{OUoq/%vtwc!_NS=h}%o3z_=1su'G7?;{.j^|/zu2}|G;k_ok [G_>w^37}vn^/|~^d6~	}Uk}#a{n~OO{uzstZs;]c':}n$?~ndN3u_]z6^iOe17=fDM5*kg}?6mF|y+m.oolX{En{u?5zk_8t9g917=Ys.l_^^y/[56W7doy_W/O3G[Ohmo*Z=l>M;G'/&,[~Nf"]Fwguj>?>jHo}{= hOmm_=k_S~5$Wmu~v<?k~jv_w?Fk+U/PC>rKVw4Weo@?Yd5_GQ7Vj_[sn}{N|__q|eq]/|k/o?y=vtL|g?*zfu-*>|tCky:zV0!bQJ,4S?}6^F0WQ=LNB7s}>z[>/7.||[Zi9~o|_|Ookm;wtw&
wWs;C?C]>nt:vI/:{}~~5,&/Vfbc>;ta.j_?/94w3SE+=&_[|)ShGi1md+wo{O9~q]oK.G~1?>Uwrl'OC<Kb^QSGO3?Q_smgtA
={{[9]{wmk\]}[l"6_r/}w5_#i4a:F}~hdgoc.4\'i+v$oIoz'Gs+sAc^pvg}?wh5|?n=uZv7C^;d;?Wgu*of;	c^y}/dj+.yxzO/ob;{w|k7O[If^M1k4BS4Oz[?Gjz~C6f'o>}7SWBo9wyNK b}uv?_Vi~C~nwunS0OBT{cJo]c${oeYz{.-.]o~WsIgyz2pif4Hn\KoGO~oQ|*_Vq[wZNW_-JuCkWpFW?O35?[%fV;1]7JYO+zZ}kU{]OWRmg6OmK7l<u-gTo~^w}G7Wcfs;}f*?2;.o}\s&s%[+kgWE^tg^~^21=&gIi?&GZ{a}z6>[Gwjo7^n~=}&W\OX\3U//x}{uO__?VmgvsQuk{u|!foWQo+r|fu^:Ig/p>|KswMZ~.x^zVmSoo^j9w]y9A{o%@m4dC?yo}|?V50:w=/%8ys3:y3'}fi?svv{s:R^N=>m{[=4w=K\1{xvvj>t='oh$w_QjYim8k_w/;Tn[<nggh7oRGO_uP?wo)~,zw_yw|k42X_`]wc'{W<ReL*3fp^IK-nQ;W8saohcggv//tgwVXy?f{y~kye&@[;}>"D^]U.
xKOS?b{@acOo^UM~sL^_Y:oMzj@ 	J`SaGMB@$c
D(a!R#0B @.V  '"E")g`H-R@8, R3A$ Bcb"h "!0@O0cA|
-dhAxh$E2c" ' B*;!&I @?,P" X	 P'*=IJ!F0 " uKT"H 0J^7WDz(R?"|_B?_7?t[zW&gKjED~wFmlvWOeur%o;E	Em4SO@-iGM~GA O/B`@xID8(lx`Z ].%XK   E* P0@ C*0 !ET A0$# ,zu{z]wcg[G%<}p?E?=W'yW{y2!@w}m\1xWh;?weC]sdiG7C>[g+L{[{~c~^YN{.fc]~w/qsh3/o{x|Sba`#B A a@@+2D"8 )	0
iC@&i K,#C(L"" DCsqHU8?Z)&,F@vI15s>ro3AE?$-LH7<W}rO];[S7f-<s=j	{vFb9^q !>@M|#	B@ ,#0uz0A  DMbU- :&dP8F3D(5 XQT5`).2@lq@!aBaR,H=`S0bHJ	/AH
Ubj hI	!A T@ R@J)5 2(
G \S1Y  0J( BkXDLAK2QD"qPl 
Z{~gVWlo)s\OPPyw[Pq5zSi72=?2ffw]n?uV"hgX<?>P!F ,IAeD;: $H6 A 1>`!	[$AR0NHD8
  *L `@)F!	@Q@0XDAC ;mmY}|/?|?i#ov<Z /m=}[x:$t^vJ1ks7zOu[ot[\K11.SB}?QM\uuh_zuNEkawozoaOO9*g5/Y4e\E}dD!6E:p >
&Qi&Jrt7b X)i$   !jp Id0B2	|c@bhD-2XH	 p@#I-$	V)rlz>s}vWT;b[y|^]3SH__6w=o.;//=E~[dcjge8A+vI   Bk>0 NILZH # F$}XJ 2Y#8PGHT/ B@tE*9H2q@Oj^K` !2f3L`X2 AArA$PR4E@
FB,.I	qJA5  	QALsD`  bB8DD0 S$(%_:<<y2L- 8N$zQ1bA?>v>m7wFN1cFj~s#/X[UveXZxmVO_Uu6EtV_~U  [@q	YA ; 1H* ~`@Pb@ Qd ).,A*B7 QrH PD L@Hq	^!	T( 5Y`*U?>ocf|Ni>jJEkVt?_s?_hus\7r6vgp'lOulF#5jeLvi}i^ZuOT$SW+aVM$4G:[+3n`|_pW/q BVTQ pL'!"k#P!$X!	h#XI: @IAX?01`AJp
	XJA"AThe 
C&X.}:U_V>b{e9+C{,^OV//fRrA4~]?bu5VLwaou7$ )#p H	Z0MA_  VAd IOA(h	'2$,u\@ ` Dbb*1qil@!8	2 TdC 
(,REB R@ ( M	'I` l$`]A	;AF
0J BF:L	e1
r;1M tS/R4:p a
`8Dm]v:  4Od@S0t}N+>\5].~"??957UwjhW/]~wWM^5?OHEk w9e_UJWko~J
T AEhF
"
HQ!)0@pHa kb-E4c5I 1p@KBvP V*CT&l!T/Mivr}&F8bdHU\-z0f^a~|_~YK-77Zk{S>Iv_
(oqw|Lc79;rfoGAqN,o{=^y-xj/ov|d?f?chRU	z7$qycBfXApU&n0F5JB Qg0X	E`T$HW $h$Y|) #tb4mLPB 0$Qp0	D(@p#1P4 3sdKmW73]J4?QnIoOBu{>^	>>wWU:9d!w{?}RHj1c T @q*D&NIP0 *j@Dtl\ H,tR8	@V @HW ,QDZ T#P@X0l [ 06 0,za0H 1%C	nb-C"A(@ ! C KEP8N(
1,@I)"^ TFdrCQ`( PB  h< rb3#C/|5b7o}|N{0^'=$w`OS,)eyf}r2/_;s'zFDHlTH0U$
CP0H H ` 9`aD YC 7169O D\	 TH PX 02h	! ;|  
GO^'k?=/dMNbm88kt["se_wA~.ui+-%]?>YU+SyAz+WY5yw'[=5.l]AVv?vc_U#8Bb
-RJHQh3" 
`aD$0) 0R62B[DBAv"64
d8T1`**cD$GQ E$HP@C % B( *\k}<B^n]	+}~El9u{_OJJJog^}}ne5M_OIsvz/ "( 5@H@$VL	  ?DPCRe ~( IQEH
`(& Y"	!PtNDGK*2EPD!H  pD`"A 1:]N  IxG2VL @!CR
	PF @G@

 E@(H 0pwgQ}vMINnkuughw9u]??]+(P:M^[7kzWn>u'}IOA  C0%DDX	a
POB   1 H@hAH@F0B<>hiLh  2B. W>?bUi&{O/=^r'B~z/g|
gowW-,s_Y/k^.)|=iz>_3-Ubu0=/~W}Ju];4w"}wmN44N~LC~K,Um>/Ero ` 6P F	GD0qRm4	 X#hb 	$PLEP 	7<08$bEQ6" P,AKN!d(J\6Hk  -)d;'{w[H/gm7MhP['GWo'7j^[	{Zznui[\.\3U>,H)X@VB
	"(:P cBLm<iLR@J(Z@    No(L#0J#Px @P#<q0`F4&*t(D3XB0p%@q
CJ $ \BL.	`
YI&J`XC	`tPQAR M /td|O;5}	ZSo#NUn0t.BtU]n7`7j3]yz#{qg@ \f8p"D,I0 M . $@
 p dpP5Rf'H1L1	d0 P  x&! jf Cj\pI  cOjncA+VpyHg:YGV&Lm/ f\y\wY[C/>?w_V{2[v{Y*_>.G?V^{_Rw#w~,zk^6rS'r_V{o?C{gm~;[Q{.{7mZM+hysdH`84tIXHT<R4		| E0E,  zN ysL#dAve! $10)B%H(Wr ^NB(RIFq "
2Qd8"A t$&yOy}hOQm^Bb5ME1ez7r>+#] xN|'NQ+ P"Ch	p@!\ +BVh9D  2x@` 	\)Xyp!P*`!.&	L
pJ!* Z2Ipe &y8 
(C;h3#@8) d%(c Lq"ES$@
 A(	FU a0 m
"<N. $
  b p!PK?M>.{;47okWo|(Tv-vBJkksuuz{^t,Sx=>kl+~|xc*s\	<{$N(bo0a}@$` e(BaCL
Qif\!=`F PTTc ]0HPTzIa B%`  ` lK!^_ZsgLfOe7k79e{/KB/:
uNxO["o.Om~|UV0Sg],$ez\kg}k/._kV:9;@lIs_ vj,Rn~/(&kv9}m0?}o;D&9:Q?+ X*	h;"#JZa
	|cP10 9y%`I	`0KA @$bj H-J4  E  <R!-"J.4 ,j  N)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"}