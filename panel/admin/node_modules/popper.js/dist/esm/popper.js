W¾şÚ¼Û)kk~£2¹õgoŸúİùÚ¯?óúßß•Şª²ûÙÓùü£½şıûŸûÿ_{wÈ·¸>Œ·íş¿_İ¹Á_¯¯ß¾¬³ß2·ß%Ç3õßßTgİÖ¸ÛßßÜ×Ù·ºsóëû®õŞw}Óß}•şÎ6Ííg[Wó6¢åİÎ~co¡õŞGã¯·&æ¼ßïüïr™ğâ7WŸî,¶Înö2ë“_ÜÿjÏRônûïô¯Ï;WvŞ[{gÑĞÖoOßùøßzIÿçÔtîé‡_ûûßÿúî?J|üÂ¯çÉõ5Ğ©Kø{øz¼ôÿ¶+‚ßdÑôı]ï…øw¨h¶³¸y{)İ«ß¾5İOQÍäq—ZíoÕ‹Ëwÿ^w)VÏ7åz:O’Ù†óµmïÿ>]£õZ•ÿ7ı/7eîm²gß÷üæKç§ó?íısıç¿,ß˜?ı<°éO­®ı¿Õã{/?"Æÿ­İŒß½ÚıwõéTy;¿?è¬ÿQú?GÕõ—ü¾ç—·ı¿ÜyT¶oı_5Ä‚ZÖ¯ê¿ï)Û¿¿Z/µúı?½³?6nı®\Î[°îÿ?ƒèïış®7óûYóøû›_ñèù]ïoüß¿Ï£şÄ{Ğÿş2Ãÿëû¶ÏWLÅ_¼²ñŞ¿şß…í§9õoÙÖæï…]œM7Û^guşnıÕ»úEs&uÿEV/ÏfÉŸU÷Úáû]ìŸe§ßïŞêü—éãüéÿ|}öz4}÷{]ÎÓµ¶Ü1M…ùŸOc®¾=ÿ6ò¾úb(OûÜÿo»ÿîúŸ\_ı‡şgt6îÌ×êãíx¿¯}s²>täÖÛS§×÷vÖcÎ7'ãï¶ŸÜœôyİtïı^£îßïÀ6İ~öï×´Éçµ«3î¸Ş½Åw»®Ş¹ú÷¿µxó7şTû÷ß[î~üoï}#ßm.şÿííæ|÷Y~‹ıo×ëë'­‹ƒÙ¦'±Oûû¼oÜ‹ìïáòÓÿ|ïûšOÇï¥ÿŸÿÿın¯mñ½ëïÿ%òÛZŸëˆ¥×ºhãİûÙtÿ8ñÏ:¿tµõ®7·×š¯G£òeßÑ~¿z[\ÿ[¾÷ëı~ÊyïyëøöúûşOÇ}yªíöù¾[=m¿ïø­ÕWÙ{Úûô¾¯ö·İ;n[¾¶n¶ÿÏgq«å³·'Î;×›î¿½éÎ†¼ùqé}cëÿÔ»u}îy$Û¶q·âbÉ%Ş÷ÿni»Ç8àõëLÓ1g½š’ş{İømŞ óõËë³¹ŸÌûîÜ_iº­•z—ıùw~§ÿñşß5;6¿øw3ùO?¸?Û:ı¯.ıæç_÷Şb­}j|ª{ÿûİ9Ñeï§ßøşûı¿÷ı×ËŸYÍëúløI7±/^eë7yÎHvéí¹#§i¿õåºa}ïÚçæİOã÷ßçñ¯†ßÛ«·ü~ŸşØã/•¤¥ZŸÓ½İŸO÷ÏûŸüú7·úÖÖí­ÛÛĞªè.¾—¹®÷½ı>üÏı©ğìÜåvş­ı}f¶u+ß÷J¬Æáî7÷i7MöOÿo{Ø/¥î÷İïcÛÑş2Ì~ñÿHq-<~¿ŞLøîÕ¶¶í>u_çîçkõÛëôi/[.šĞï±_:ø/÷Br“ÿùßBùÍÍu5ûèº1?şÒBíçFŸŠA•~şúW>¬òügôögºc×ìšÎ~Ù_×=i5\So™•ŞËò¯üZ÷ÜOŞ™u¢Ró¾Êw›vŸËÕ×ÿşyVĞTîi¹w¯_°äü®ÚjßÓ×ÏVuç¶ímãëy÷›~qşkğä·÷¿?9ùu]‹®ß¨ßÿú—»—ÿ¼Ëô{¿Â¾v5õE–ö==qùæŸQæÈÃîcg¡ß»ße¿¾ê_şÃİYûáûõş<ö7è³ÆÛÜï{ws÷Ê®üüL®÷½Ì¿×ßäïıõo¾Lõé¬¹{ûì=ûıë±;o­v¨ù÷ÿšë>ûVóóz?şÛÿ¦NÛÖóóOûzŞïí÷ÏÜß«òm‹ïŞo¿¿âŞ‡W2ô~;Ïc{W¬ÑÛUş·?–û»]îêuŸ/«ëe_çú]ã}i»+w4åE»ê‹¶ÆıÑ'e1ŸÖÏßË}UôNúÊª›İ·ôv}ÅnÒ,Vš¹4‹uÔ¿[Âãn~ÿNûoÿ¾…ÌûÄ+_sz\8Ÿù=¾ñ3ò†R;Õ¼yfîßşóÿ_ôÿ±?öÏêÇüÿö_fõİï}ÉßIíë¿şıÔ¿/Ï/oüúµ?çØ8óõŸºu—>§¯æ÷ùîuÿıÉúÿÿxtu\û·æy>õàœÿ5ØİP¦•‰Íû_~ÂîßÿÏÚ¿æ÷û¿¹÷{[—ÕŸ÷Í~ûÚá¿Û?·§{Ûş·óël;½toÒ:ÍÚå^ßíèœÏ½Óßÿ?ï×Eö?ÿ¿ïÏd×õ¼ß{ïã<­Ùçı;_xUïæ×z÷ë»Ë³½×_×Ï¯\?›}ºë{_ê»¯~ş[¦åë¹ışõÍ¼¿¾Ë»Ô²»ûãúŞ‡;™ß¬Ò?f»oyª^õşŸåï¿ûr·ï‡÷³=¡X×úï·¡ıOéÚˆ¯»¾²öÿÿÇÿ¾—¿ïÎËı÷óDùV}7ã¿ÿS¯9ø°î|ñÜ­[ş†nÚÕC¥SdwÆ×¾Õ~ÿÕOk«øÿo#Ü‹?²÷ÇÓ»§—÷ºõµmÿË±ªÿƒ§	°ÿ·_ñ½Ûñÿ=gİ¢=¿ßçïtÁzjŞ=½=çÇN×÷=ëîÉÜšÜÊ¬ëyëÊ¾?×±¿ÿ¢Şîÿû¦ûçÛmÎsì/9@mşŞğûÙŞßı?WGÒ9w¿’»2¿ùç÷¯ÿşû§cwŸŞ|Sû¿ııœş¿X»È}×Ÿß÷_÷UÔùvÎÿŸÁó5Ï‹=M²FÏÏ=ñİoÇ«:ìwÿæOúØé-Ò9­Îuª“ÿiöxºEÏÓkı¥¯oêßÿ©ûà½mÚ¶LUü.@é)ex?6~¬¹×örúg£íäóîìŞ®ë¤ú7zªSê¥ÿøû{¿“úÇ_×õ8'ÿ÷F_?ğnœŸºÛÖD÷~_ÆóßÅ˜¿“ÿ_ÙOè æÿÒ_ÓEÒuÿë÷Hå¥PWııwëÛé¹TË”x”æÏ»ÿ"E÷vBÛÕËVh¦Øíÿ¯ÁŞÄÒö€n•ü–“Ã‡ŸW°ú@PşÎ{2úü²öŞ°×¶öóN¬>çÜòŸß›FßwÔ³ÿÿ½;}íşïßnıuÿÇoYc=ÿ~ôÿíïp™ÿ»×Ğÿ"ÿßéS=cï5xÛkiıÿÈ¬Ï]]¶5{­Îv•í¾üKë³_ı÷SÜ;LÆ|ê¼¿voo’Y{ÿzIúÓ»jêÎß?×o²ı»“6oÜöôÿCù‡ÏkıÙ¹×Q^íµßÙ}İ-ÿ³¨ÖŠ<û½{5çè[û3)›¿ÿÆÏ=å~,µòß°³Ü?ßş^û¾Böƒˆï_şrÙ×ŠÖí/ÿø#¿}ÎwËgÏô­Ïømüïş{[Ù[…óßüûnúé¾Õ^|mäÃ¶sïséßôX’µ¨µÉõìÿ}/ÿÕOûŠ³òó<ëíÿÿ¯Çß{YÓïiı||O;®¯êİmşßa{Ÿİ97Öı<ıìµ÷s5Óíùwõî÷·¿;qçïv÷2­çKÍ<Iÿq¾Ÿ|JßùïxZ4ìáá×v+¹¶œg[óéÚ½¸á˜ö‡›^õïÏ<ÿ¾?W‡Ã÷vû7ï²;{ık›lÚôR?ıg^çûÛøúéw[ëì{ó-×ÿüöCßÍüt·İó/÷Ø¯à=¡ßì¿›ÿÅÌ´£Oÿ½ç´ı¿É÷_|ÛîÜÿ?ª©¾?o¯~ß`VS?¨-³}ÿÿ×x¿fÕ»cè—çíÿ:z½|ñ½=~İ¯±‚õ–ïsºÍúóıÇ<ÿ¯«**ôšàïË]Ê?~ïpiòõ©XÛo]GÜ'§W}·ğùoñ×ş<>ßbîì]×ÕÔ[CõéëÚ·ÂÔÚ{»íÊO?ÿéù*ıÿg§v¶5;‹ãäÛòÆùÛ»òæ7zlÙ[xº*Ç~¶bï¿Ñ‡oîÉï]éŞùöGå½ê_tq‡L\eİ]ÿà˜­Èó/M†óªK›«ßÌş×>ÿ»»/Ûl~=şŸhëıëá»Ì^n½Õj_õˆñ^^İ{úÍ\ús÷ûÿ¹²º'Oãô?ßÂöş°mÿõ÷k¶¶Çí~£—_½ıüïÙß¬ívŸwrıY©ß³Ÿ™Ö~û½Ÿ¾é×ßªÈ>ö®yÜ%mÿ‡g{Ş·¿ÿy2ãğÕî|º_’í·çZ¿× lï¸î?«ñ×¿Gú¶O&ótQm1CôW[õyÿëVÊ'Çé§PÖµäC}?ÎosùY¾s:µ7ÁuwZ[®ë-›jŸÙ¯×çÓ2®Şòîğ]õwÛ(şß‹Fğ=ßï{ËØU;}>|šœO_¸¿âŞş^ß[oÑÒÊó•ï^~mvÇõË7o½¢—G÷ò§Ï»p¾ßÏ;Ø-ëãsíÿïµ€„ïmê);n£üÏ§Tœ¹–Åşä3ÏÁ>V=åÛØ­Ô”ï«wÕÁ)ıÆ®ú¨Gæá•ÿ?ı{.õıéÏõ^û÷~o}Şßò±WH¯7Ïû;®ïÛËoŞ¼áşm#ßdERÛİ?Içök:JùJ{şÏïhùü¡ÖöşÿÿµÏ°Ë~gûêòÿ÷w\¬ıûs/üíª0şç×ÕÿùÃÌK³şÌnÿûß¿ğßÇ]^æßz{ôéßß·úòÿ|cüõ	Şmû—ÅÕy}´òï|¹wŞ=ÃŸÅßY^RuÿßÍNíêP Úî£Ì'¯uoºôÁáğÿ#¸oëÜ°ÿÿİå‚±Îû\×óZúÏÚ{ÛÈ¨ê²§ì7ş¸ß½Løş¤çıIÚ™ıúÍÍ]íçõj™­qo¾lº¹ı£ùÿ¿ûûÿn¼¿½7»ïÏÓºz–?÷íÿı½÷¿÷ÅÿÛ¡ş®ïİqóñöë__õôß¹ÿà¯üö¿~¹Ÿ¿ySã½ç÷Ïëş´ß_{WM³úÿMôŞŠYÉû:¶ØÿcûòıË7İ½Çşïßÿûß¶ƒš¬¿ö}'ûd›»v>û;»ÓôŞ‡ÿµôûóo~öü>¥ßïÿ{üTöÿõ÷M_İÿ÷ïjyOÏ5íçºYÿì÷™ïÖû¸e¹?+}ûWzøë»šK¢ïôÔ}ÿ½ŠæÙÙÿ»îÆ¾’÷şí¿ü­í_ßíÍ¿×5ÿükÙóø_Gm¾İùİµöNÇ_İúùÿêú·~ÿÿùÇ:\áÇôíÓŸÅyuésãSç÷›ıCÿ¦·×5õÿÄÿwâû×£ox§Î÷çwŞ‹ßŸçş‡cú:Öm÷¼­æï™j?ŞÚÎkÎyUø›¦H¿Şbö^â„ßŸğ÷MµÍÅ«ïÙíÛ÷î÷€Í­kÒ}ğëÁşö³/UxĞø€{utedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && parent.nodeName === 'HTML') {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popJò¾_>ÿ¯Ö)öÓnñ»C6ºSŸ/t|gÜ-§Ÿ~Ùêmò¿“@•ÏŞ¿nM·¥©^Ùæğ^Ö-·flòçÍ‹÷û^×?_¿[KbÚaöáí;±òîûíÊm¥>ù~í?§2¾º÷ãûıñ»wlg«—}´ÿ?UıF÷õ-½fnîeNäôïy}Wzş~uÿµc¾êó|ş¯ßüóv®_ÿZvİßıüEû~ÎŸ~ÇÁ÷vïı|§§Mçõïonã/=¹£_ïéÿVkm¯¹Œ_ú^/WMïöÿègú8ï¿ƒúnmû0ÏñÏ+ıK‡÷§ı­üıŞ×÷uûfûãsÛ·ıeí§ë~Õ¿l×­¹[wIŞãQu«ÿg~ïÿSOÙäÃß¿¿­;]çs¯ÂøúÊ{H¾j³Ÿ×ß×¿ııÿşşáwŒÜÕfš¿Lß¿ÛŞÃ[U§ù é×ß÷u¶ÏÁÿÚû_ïóÊıøß¼}Ìæ´´îÏ¯ÿ_÷ù©ßËÜÿÿİ¿ı_ên¶ë»w¨ƒÇSuïßâ×¼Şşÿ5¾÷Ó…÷÷úV¼•Öö^-‰Ê+ú²µóİ\ı_ ú"üóh¬1íÛ­Ş³y=ıôßg|í3é=Nç³/hxâŞcÎ¾Ûı_füş*^ı©ìÓ®Ák¿½};-ù¶ÉçÚw yª›Ï·ã;{ÏŸßçÿ§ÿğ-õ}xvÿ_ÄĞßf]G‹ùïl}©oÿküÊŞíŸÇÿıoÕãíĞ¹íı…ÙÕwoé§Ç÷>n{Ù—[Ú3iÛæÅ¯ïÿ[F½ŸÉ?İÌÆèvÿÿÌsÿÿÕ†ı‡Àï>ÿü¾{ôYü{îıÓ£¥·ÏÑë°B«[–7ñÎkxÿŞÿõÏZÕ’Õù¥ûiwó‡ÉAı»û—ğò—yìş]üÏ#–‹],Ÿå×=ƒ{³½½?~ôÿµÙ÷ïı~â÷ÿ{óáå_³5ï¿øL¯—ôOoKÕ¿K¯ü³›·ù}ÿÙw³C:Ş»å©Öwífğïûw/õ‚Õ´/şåÚ9}§=ïÔqÛ•ÛıæîoûDéº×]W2Ÿüxm›'ÏO µWüã/Ùöçœ|ç±{‰³ŞÙøÇv³áß¯qîM¯w¦{çnzrÍ¶òí ¾>¾c¶lñ3øùq®WÕ3<¿*Ék>UPí¡~hÇÇ/¾v¿÷³Í¿Úk/vM§ç¾¸ÿwöm¤Ç¯ïß¿Uÿƒûøgú¯¯‹t?¥X=ÚÖ½Ë¿Íüö¾8}N}¡,ÿoæ·ıoúPoW×ßâC}«÷­»ê¡T±{ÿÅıíù÷×¿à|tÿşû}_×m^ıul¹[ÿ~îÛ˜¥yu_ı}ÿo|q¯_ÿê»Ïúóº~şñ?çòÇ_ÇşÿıY”öùtßíòÜ]›±îC?P‹Oqæßß÷yÙe?·{Dï§Ë¼;ŞÜ+Ë	±Òòw?t»3ŸûÇßZuÎ“jûï=ğÃïÓö}[ibşVÙùûÏ{ß‡wùÊ8şIŸ-ãÚ÷ç÷ü¿HsO%¯Çı|0·Œj1©İ/©ğwœûµ·úı|ó‹kúÿÏü«ÿıôßşã{öìÿÛ4ß[ú¿¶÷úr²®’úöĞi¿œ¯Ömÿ½i}8³œÏçùı¾7ëîùïç¿ëüüÃn®_Éw7g®{ñıì¬ï5÷ùõ¹oïüŸ?şû¿Ô>¯NıÇk¯wJ¿ÿ½¶ê¯÷ş|ìõ˜V4ëû_¼÷Ãnø÷ç?gV§ÿ¯xï7ùöß®ëÿ‹Û'çßúeÎ®nå=ï­ïÕWí¶ï{ÿüSfOš·ŸêÖÿ;»Úuƒîñ…û·ıÿİ=_ãäİöí·úïú‹ë‰5ÚëOÿû<½û?oÎ›»~uÏë¿ıÿüÕZ¼÷ãËfú³Eğÿ¿Câ[÷şÇŸæxõ—¹ıÇWÿ¯.Ç]y×FK­¯f·ñßıOÿˆµï÷¾MiWïbµy–Îß÷ê½î­•½¯ª+ëYw”gãß²íÌı0¯¿;ÛÅ×w>Ò?õNNs/8‡GŸ»ş•ßßfÒ³¬ş¿şÅ(6¯Ö7ñ÷ıÍgk×MÈóÿ:µ½û#ç¿ìÌ—õåóûelh¯ßÛıÑÏyı?ûõûû¸fßKı>ızûOşQ·{_èÿ÷/{÷/óïŞ”ç{w9ùÛÜı§Pïyáoú¼Ÿõãm\õªaô¡ª·ß¾¼ì;Ş=û—õ£Î1ün­Îwé®¸ÚjÊíÕïCıëû§Û¾Ò;«õë÷²áÁ¯‚¬›a®¯ívp¦ºù]ìwÖåÙe‚·Ó] û]å¶ñÓsNÚqßp¶ÒtöNïÎe¶‚Şìs/ˆñ”q–áá¾u½ÔnŸNJå<s÷ô)>Úüş¶g=Û}v¢¿vßñTRî¡ÿ¿\tşûÍoôŞ™çÜ/ÿß½½‘Wÿü×(»íû©]Şæ:ßÜş?¿ßÛ²éh7ïîö?_İ—«ü¿öøwıÇ×íß!¾#Ö3Ï÷³îç_Ó÷Åò7_{³ı£—·[O_‡òØ›ŞÏyíøÅW~WG¿®ËµÚøİwÿÙ]æ)Q;ßßkïS­_XötÔ©{÷ş×ÿËrïyvŞùO3c·/kg©ùï+}GÏøûŸÿÚöèéŸ³ûíîûïçÖ·şy¶]öeZÿ÷š÷¿#s÷÷ØoìL¼>éĞ­/¿9ô[OûßWıïÇõ×ëÙÿîëöø½s/ñw¯ïœşî&W«ãíïé»j¸^^ıM·[8oÿı½z~š…ÛÙjß¡úş÷¿¹şí\öó[6>[×úæ××½6û÷ëÿ}æ)Ö|Ë(-v«}ßû7é¿Í/åOùqÅïwf?(üŞÚÿ6GM÷¶İ/²¾~Ÿ ÿ­%S×s¹M³ÛâU×WWrt[õÃË½µú@ó«_½Á¸ï–wıg$Ğr¯p¿ÿ=Ñ{‹æ >0'ÎRşªÿ»æÿì>;o÷ıûçıŠÿûŸüº»÷8¿¿…F9ŞŸÿèúş×Ì¢ö‹ıïæõ¥¼yïeî»WÕŒ¿ö0Şç×Óëıw?çö±ôë®æ~_Öûw¤½Ş×qÖÛ{¹óO±ÿ¯cöögú»óÿßúîw½ÿ›ùşçM×¼T}¶u÷ı÷Óß¿•úÿ¶ûìÿe£s>M¯Êşë[ëúÓÏÛyûÛİg-ò·Ğ|×÷E[ã¶ãEó­ÿåÖ2«,¿úïø.²í;íÿÇşíï‡ßõº¹ÿş÷¯‘_&™/‡ÿ<ÿ¡­“?gsÿİëéÓ_÷•ùæÔßwªÇ³—\2F¿¸£~­8ı×Î—_püÊÒêu¹kV™^>ğŒïeƒ{}eÓ–z¤é·‡½ÄÃ·K%1ïÇ~mš_Ç9ÿöã³şÖsê‹OõV¶W•ö|Kûşwñ¯¦å/¶sŸ­|&ôüü^ßïôÏVÔn
¶oó­òwhw´îßd46ëë¬úöSg}¶Në7ó½Ëûõª[ıÿtÙ»úıÙŸ™ıËş/Õ¹wşüıßo!ş}¼Í}õú3ömovr×î¿ßÿw%^Şòî|ï÷7{â7í¹9UõËYjŞ¯ûWë4Ë·¿¶ø?Uñ|Îıôÿ\íVŸ+×gşÏú;Ûİ?kµ›ûg»ÿrßM½šşæã±?¾Aè—ŠÛÙÆ¾géı‰¯y±_iå‹-åò6Óß/Ù>ïö×¿îÎû³—W<2£*µ˜_QşØ¯ê=mO/<kÊ’OóÙ”›ÚŸÑĞã_ÏëêÚzÛ÷¹­ä~õşú=k9m™şñ¹õıWå=ïÏõ6SãwmÎ©ÓµGeRÎ9_®Eñï–G¥dù_r½ÄMóP=nÿoÿv“¯~æ½‡Ø»\é~~üÉ½´¿ûßpM¬ôŸ÷wÏ½é¹y×õåé¯8‚vSË£ü¶¦ŒOŸÜ¤oìzÚ;ñíŞ?Ÿ÷nû]]şO?dÿ~ê‡~º±=ĞB…§<'|n_ºş»ØÆ…â~ßğzíßŞçõe×r:¨îtîıïÍJş¾’_ÒÍÿí7«ç§ß>/}/yßoíiï~kœ6wÖyã½¼ı¿û>¯c—íÏ×şßöıßÿê}÷ş66¯f=Z˜Ùµõ÷şßR¼ŞW;äÓ¯óïêßö»kê“Şø]ÿÙ¼ÑŸÇùö~í‹ÅOØ&~«½æk&İ×WüæGzhQwóéK:êŸöƒÌ—˜S-ÿ-?ÉWI5ÿQ]Ÿ_.Ï©z]ß^}Æóo–‹Ì^yë|ßø¿Ş—ö_>½Şôòj¤¼û¼ïçßûø¿cojæã¿t\[üóôäñ“'=Ï}­’ïœÓ^İußÕÖWÓgÿÿkúæßıÿ¯×¿åó«ÃÖ•¾¿k»¾ï«³şŸïı»Ÿ\]úú›ŸoÚnV_ÓÜwüWêöÿgv«œ®»ü'~ÛßÏ¼õµ¯[³å÷ßÿºõø·ÍÂ‡ı8ù{ï™¾ş·ß‡»6ûmÿİ¿k×µóÈQÓÇÍ¾ÂŞÿ±óËëş­Yÿ©×Ï»_ü?6¾œ«|ß´ ¼?×ô¨û»;÷ş=öµOcóöáıŸşúü¸›î¿»ÿî]]îë|ù~³xÛşç&7÷½ç[İÿáì÷?ı—EE®Ä¬×^>×TØß³5_Ûø½´ËŞ-TwO÷µÿû&¿¿½¥Õ¿z¾ø×j}ş¶wÕïŸßÿ2Æeßş?äÙvÇçú®¹®GıãÇ?F;õNO÷¯ßl{†]×;Ÿâ=ÑG÷œ'\YÄ¿Öß%ş?Ş—¾OÆÚ;÷ïïüıB¾núÆ7¶ß“ğßîÜÓØKäQ÷ÙìçX&ü·ügüs¿Ãÿ“­ÿJûx§İÒ;»ûíVşÏë•Wş*ÿëw¿Ş»ï÷ú5Ó]t÷úµúÿuO«¯ÃuúrùşŸú^Ïõöî×ÿ'5åı7.›Zÿ}õşßÉ÷v>>Ïd²]üÊëİ»û›»É¯Ïûßƒs¼G»Ü‡İ½ºüu{OwúÇï›·Ïú}ûçªùûı«º÷~Êıæ÷k/İSÏ¶§U¾ßó:çÆïew<ú#¯³}|÷Û“¼ûÿ£ôïo.|w~6¸úúvğçÓ°ÿúõœÿµçÒ.äF¾Şı¦äİü¯›¼ÚSşÜÜ]™|%5¿ËÿõWñÈ¼ßˆSg›wµ;©ótsE[ê½ğ—şåçGGìâ²ëó¥u;y}Ù·?fü©í‡é;ÕçÍ#Ù[,¿u»Kîp_ÙoÙ™zkï«ßß4|~¢ŞeTó>ş»éöëbüïşïãıM¶\±YÎ÷Öº4ş3óåoÚÉèÓw¾ct¹®w÷‹—¾‹eÚÒ'ñÆü-ıôÇ½ıÛı¿_şmÃt6õ<É°ı÷«®¶ãcÔñ¿Ûo›¼Ou¾ÿÿÿÿÙyóo$?o_µşoìûî¿¯·÷Ÿ·u¿k4åy~Ÿ÷zuÛr~^ÿıë·¬Ï½oø~ŠÏß·‹înÿv“ÿ»µÿ÷ö~—Cû»ÿÍË=üşnğ­8ë·ü¬ş¤ùnş+—oî}ÏQvLú-/~UÑ²ÿacement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // Avoid blurry text by using full pixel integers.
  // For pixel-perfect positioning, top/bottom prefers rounded
  // values, while left/right prefers floored values.
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.round(popper.top),
    bottom: Math.round(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement =7ŒÅRJP t†‘Qœ(â`[8˜™@Ê  #@„r€¬¢ ! ùL€J`n¡ b "‹„pÈQ8.˜0pO<L_B 8HO®2M€„ˆ“#Aˆ£#uÒŒ‰€(:1 Ó´R;8rS°à"Ú h«"—$'"Hœ°i4c4õÖ˜`1(ôD1‚³œµÒ°X,9€I
n½Ò’Ã$È"6’j›¦ÑÖ°^Ñ—ÖÈ†@ˆ#U …~Ğ’„{„äc˜yX”¨ Ã0# œ`Û*xQ€D°QQ/zFŒö„¡RH	qATD ´2 H°« 6Á®‡T5gŒ  ”2 €K Ô”P@´	9ãD„âAŒn A£ğP„6ƒ1Ú F&P")&‹C€d 0li$8=áD‹€XÖD.CS@ÆŠ#, ”7 æ˜h@ Ø •DpJF Ò À NPh €( d*  @É" Â#K`‚ö
àÄ(¼T€¢Ğ+HLP#€Ğ¢P!p6!Fzºl~ÜĞ	@pPjùH&,	AXE(¢%‚2E!%‰`À®J @+	Bxä !GcçéD(b#+ª
½:ğB‰E"ra³1
$RÀ€‘+@•V€’§ŒUš‡ğ\$RvJ#NX‡$¸œX‚Ğq` Ékr €	 $
ÎAOp ÀB"õ¢¸R…€i‚dğºÀÚH	¢Q	ÃS€,0€@ làph‘@˜ â I!Ær
>ìEÈbQ¤(cÂ€³ÃÁÌ2a$H;Á„X€ °j .h	 ”«Àe'R 
À¤È¢Œª‰@W"0uP A2
`T@’ 'ÁI@ (ğ¢ú#  ÁÈ`ÓQ®‰j€Ç)ñ–™
,2Ã‚@A,ˆ bÑ+6%¥D` ¢çá$A  «0gÄ
#1ÁØƒ:)Ta©*TB	§$! Ha€ ¬€0%Bd v¡¨(+8¢Ùà°ñğšQ`4´I¤şh j¡\†zõ  <‚¼„l Œ–,äED+A`Ò°=Å2w13Z]D˜ ñXˆÒÌ†«­"W 4ŒTà œPs Á W
ÀĞ(jL' ¢p¡€8ĞÀ"(2È¡‡ óe‚0È6€9èÁ¨N¡1†@D–DA…
 Ü$I¡#`# ¡*ÀH‡"‘ H–!  4 ¤P(H•h¹CÖà`FıhRµŠ ”•!BUôEñ¤“ 0bŠdU—FrÔ q”Z‘Šà…ÄŒpÑ¢‰6–Š¢]Â@£ ÈBš²²H‚# ,(ÚHN -%3Ø‚´QòywÕl‚(ĞãÁ¤sÑU"¤"{ˆ‚€aÂãœÅz„V£›À¶GFEjÔ ±A7 RF1*‹Ë8gR`˜ØËhQJ^ (°S €ŠN6T?
Lx„\7èÄ(—`¼‚`Ì§*D:L¦¬/$‹È€¢dqVE%’&bä«l/’kT„† D ‡ÀG%DÉS^² Š œ €@=ƒà "
„Fä€$
2`ˆÈP ’‚E’8ªc@À*(¨‘p	@%£@B \BWd cA‰¤H y£Hš´DÀ0‚ :‚0>ÃApn [ĞĞ|`GD@ŸÑ@ÈàLH£N§WÖØ-ˆ¦ù¤€èd\0 ˆ ğ™â´ ‘Ä„Aâğ¢[MĞ§“à@#XUäÂ€Y¡Dºp6¢À´˜üUÅ"ô€ÑLÖ
{"B‘Œ•	R…¼vz6 	ÄŞÂŒú<(€(cBt€`’Â )  JÑk À€XêXÉˆ•H‡B`A?@pj„,hÅbÁ  %š
D"’u(!âCF¨#0@Öp°% (Tàn,Ö ;2:nØ  @©Jô&PÛ@ bíP Áp	S@ À7Î-¬ñŒ¨@©Ò@Ğ:Œ ÁVàğ«È%!ÀÂ	tXBL:(„¢‹Ûx˜X€§IVárd¢ B  ”j ¡R ¢lÍ% 4ô‰`‚Ë‰Cb]áÎM°ˆ¨Š$Ğ@ò ŠB XpâÒB €cGªG†hi@I¢îœ
R8‚Oƒ$BHIu¢p°¦¢ +Uü,¹Eæ* p 	[ó$¡	G´Ç`„Tà $I"c1% „ôGlUd@D„@
 H(|( €]é¤ „àdá „Ml`T˜‚§" €jJ@—Th†HœBÑiS(
 "JE
d€Xs 	’©0-ÙD~ Ä€¢@z…e CÄ
C‚ €0
;ĞÔ0
Dè¾E C$M!ÃnèT  ‚„ ğDP
Ñ`‰ ,	jÈ;Õ
	~		Ê ¢hÏfJô$¾¢‹GŸbÂ¢@Ğ×BÀÜv2Ñc1‚€ƒá@Hz1Ñ0™DxL‚DÆ psÑ“HË†‘Â„”Ô.BT!Pš¯,E<ºH  I?DhQ5¬¡	 "¥4$+4ì™@‚ 9.D‰†€B1±äH‘Aæ‡œ¨BI\Á‚P+I`¸ Z—B
À³€$±‘pN	 á¤Ol4¢¡†ø]äÇ€R·!NRIÊ¨’"Áhkâ.“‰ı‚b8l ‰ j0H)$š‚Ø
ù*„	S(·8@b€JP!i.€xCğ]eƒğŒÂ@
0`P„Š¡Â2`ÅòğL€…x’TB‡ BCx€™@@Y8$Å$A –@‘ 5— ;)ğ HIr"H PÊŠ$wdp5§äjÆÀRÈ ÀìqÕE-CÄ5Òµ˜^@fìÁ1ïZå–,aqyµ¤çF Ì ea2q¬¢%»„$T ä
$IIĞdL,€ARã}(œƒÀÄé(H…=H	„|  1€0ˆ €1$ĞÙA(Ác IDbÔ°!HL>š’# ´Ã(æŒ€*¢k™EÜI	KBğ 
ƒB€ 1+ÄT+	„dˆ“b†£(Ñd2Œ²1 1k@X 0¨ àœ!1ƒ#œ€P#Â!Ê
P*½­¡h@€@F@eÄƒ1 ‚€!t@íElŠ°D†t !ˆ6!Ò„1  ¢é0Eé(Pä ^@ C  ÏÉƒÀE8@@,N0†`A(8 š-: æ 0ŒBH€)P R"`$œ½äˆã¢	P”&ƒq‚„
A L	2å$(0$kYˆœ€HGpÄQ-‚DD†¦!Aó|rI"lôŞ¥3‹OŸO˜¡„B‚P@P/‚0%‘È
yD£ \I%8 –! Y³&PãÑäS:€`h`DC` IŠôDhk&€X™z€ †Ã„ -ñ À=%ÀæÀ +(·'„ƒ€2Ğ+†BQ¡P 8”E DÅÔN–
†ĞÀ¤	(L l%T #‚ ¤Œ„.%pFŒ0o Sƒ@¨­ä€åÔÆ³;
a™	°'ñ$Ã£L´‚3£[P€1ĞeE¦6¸„D„…0€ó„d©–„ t4"%%UUD' (À~D,$+¬D! • Š•>äÀGM•7(†H|ø(Ğ¾ÔFÄÖ&¤A”¨(iˆ­`B@ 
la Š° I¶‚+°º €Àà( ”–†IY„¨%èØ”R%Œ.+¥. ˆ`¨hÚÀ$@@dŠ¼p Ã€(„äÙHRà  ˜sƒ ĞD] `€ÓI¡‚"B·€CbÂP¡šÇ ˜„ m€–Á 
8P@ˆ@€”k`	È‘<%`0 Ä6ø¨,
6$ˆ#Ñ ,@ ®G  c€CKÚ‚Z	ˆ¢D(Ğ¤ÄE d`…æ8  @ˆ“(@‘^¢‘r¢ ’ CH	púL–LÄ ØVİ*q–„ ,B«ˆ°K'Å^ÂøX!." c‚Ñˆs×ébf)ÁiWœ)‘T°‘$0L·¤Æ³† £ÆÔV ‚! ± €*0AsÔ”B™1"é·‰í	aX§@@ }€ŒE5<RÊ€
dÄÄ
I(?QRï—ASfH«G8,½ÒçåŒ‚x"‰03Pˆ@q¦RdbI‚&b¨
ä
RÊfÈ%B”$Àyµ  RH‚t„¨ T5*8Ba €¢Y‚$ÀFBP ¾:X,¨Má¤+ÌÁ Æ80€ÈÓ‚
 ÃÀ]AjÁ´C.0 ‚»ÀmÚ­$°Q‡ Eò„”ĞâBÜ€‚hÄh¨*º(l šç4€ UTB ÀrÒ e‰AP¸±@)¨¢CJ	é)³"É0	€„.A ¦³®ˆ,p"BdO xä ã‘ ‘pÁ”t.x2Ñó6l5„˜8A"M(Ğ€ğ¡0±L²T ¢äL A. ¢@&Â”"HCuG"’dk"E¤%`†jBœĞ€øi†<ZT@,–…BÉi—2ˆprOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offs"L,á”G2  ç#É6N¸¬æ¤ $à˜Tq±D9°ôË'’Fèå€øÛ) 5ØÀĞ€C‰RÅ’0h2HÊ› @Ğ‹2Bvä<EâRx±B+(
ª„ÜÀFGˆ¢ÄíÈN\’D±¤Å‰I˜ 	d  Î,‚d	¤€ÀeÈ "° ‚ ¢  æ `„]PP„J#V…P*ò  òˆC H ‹   ´  YHá!Q'x Pğ@%`Mq‚(@‘Ì@ÊI`b%;h"‹P °9\H4 WD  # “$bÅRx ŒQA‡@ØfRBB…(ŠiDÔ !\  U D`dd‰ dáÁ€°4Y!"ÎwQƒ
1…=A¾YL§P‡T(HPc€$ Ä˜M'ÈšØ 	hÚ‰¼£ WÆá±i‚&U”¥ `nEÚ*HÈ+#bd‡´€ ÉbF¨± 7 Ì)A3"lˆ`  0@¶!ì‚*	0$QBàJ¬‹_, I™	"
0dÀàÜ@¤¬Ê˜˜@AF:sgr" Ç<lcªr GN@å‚ K°I!("D| p…!"§“ 5EX±ŠF4MBDTÁVÅ£øDP f P `J  ğ¥‚à5Ã`  ZX& à¥c”©#"Ü*2@Ö¬	¨ˆ$$4 	 gq â©*Ik½i$ K S@Ó($rhôJD5 ¡HÈº
…¡ P#ê& Y	ù´Àqz.
Eˆ gfÂŠVfš Ê²,Âµâ11Ó·À€‘ƒG ’ûBXŸ®Ab€€aÆH&'›ÄÏ2Rp¼† Šœ+€d°Deîq‘ èTâ±Šbv…$  	6àl‚8R'8aŒ%Œ1HàÕ'™*/;ºfØ€( 6$Õ.ÃQúHà ¨  G'&hri#ÄG¨	cPª$30eJ!	 %šJ `ôw€R !ˆ€ @¡!p‚‚Ô‚ˆ`BÔ8–Ğ R á¬eˆPº
düP 2D@1=‚(&-Ğ%P@”)¤EQ€ê‘` DŒh¨8"ø @H0c&™a€(€¤Åá‰bD °P	†¡Áè *øPSØT¿a_'„€H: ØC$È°‚AÈJ+Ò²‚%EQùPğ'(ñ#F,ğ(¬ò‰²›Xå`(´aªŠ$‘->! €`k2À 'ËÂgÖ-³`W ÊD¦`ÎğQ½
pp1 ¸¡ëd 11Qg”ÒÖÄ"†¦ u@ (C AD(Êƒi¡ƒÑĞ
p€j °§
 <à
­ @F `'b­>Œ Øä¦hD`U ¶*AC	 8`\IJW€ €h@qÒ Œ2 U2)Bpˆ CH!A$4'EDSX [h!ZP€L@††2„¿: a”7
 ) B94+@ãÄª 6 1FöT°¡±Ğ¡AAD!€À4ÄƒYD0Ì(à	P‰(
Ï”Cà;ˆ” ¡Œ@E‹Y…‚ †D™ €* ¢êëq >r&ĞLa1$G4'f «\Ò”@Aa,D¨ ..ØDRÉ3ö$„2£ú`"3‡8E —,‚bB°¦°zNÖ µ4ÒQÇRP€P•T&*@0Ö	¢šEQ)ØK‹ÅpC+ ÆD¨xØY„ Ğ*ßâ “1èg"%î”‹4 0™@„X%²Á N*I@Œ¤°HN€HP{’$3  8%!Ü 1¹A"  0JÀXKuL@"FSWdÆ,‚F8¨Ê. \EÑ( "€’Ã@…G  ²+ü‚9Ò ³¦'‡ Ëµ,Ë5µÄ‚@†/3¦èQ$	€øfôB!xQ:»?ÀHäY€ –3è¬t°#êOp’SE€	ŒAg?P4Qf*C3š}04? .®Qq hàBBMIˆeUab¤Ê,ˆA=¡ ˜
€5rP$!‡:Iâ)å£ õÜ%æ%;*mÂ@D#rÔ¡ƒÄ ç$Prl#(†¨U€gÙq ìm¢ k²$Ù”$UĞ „„€SpÓX1ÔğÀá# *Ñ`´e(
ï¡H¤`Àp*æ ‚˜MÉE"à5	hˆ€ŒÀÄB‰è’A€$Á€¼®
CxFØ„ø*   
ÒRn–€Ò@p7cÏHN€yQH0ÁŠ¥‘ñ¼!œ!¥L$ôh §¡y£“TK4á*%ÇPpDBV±À\ftNPİ-qÓBìd’%] 	 ‰¸“DIF% ŠRYÕ¢f.@V$D±IcPS$°Ê¥æ Òôr( ’q%(‘Ç[ŠF¥-šÅDH C„0m „H2”&ğÕÃ(„ƒ(òE%‹¦PL£RĞJ1pDÈÛĞƒ	hkÈLb Ø… B0 €QÇTÆq2a/› 0°’]+C,DiPŠ@ $ˆ‚P	HCÒx (B¾˜`¥b5±k X(€A­‹Î(¨Œƒ&.§`)æĞlP! AP z‚Û‚´hà”˜ B&hz1Ô@‚AeŠ¤p’``H   ÀRZäĞ€l 4˜(ºp„u
Û°È'0 @¹†ZP ˆ3Ú8 Sª € ƒO%óÀ	^¨
HyF ‘“ä	áNÊÅaôAmû š°K)W‰è!Àã)ŠH,
ò5x÷$RDJ!ˆÅŠ./B  &°J´lÄ‰lÈÒ¤f A;LöÀ
 ƒ°^kÂ@H®Õ¬0J#;ŠZŠĞ@A¨¡Ô„U€€ B© 9x IEB5À ld& :¬T)„rH0 4äFFH!òšDÅá R€  Ã¥CHf|`ŸÊĞPWÈ%4˜ Ã DâM˜	k‰Ê"n;d8Œ{s |(¥şZ‘‹‚.j
˜Uàt 5”P1…‘Ù!VÀ˜RÍZš>Ê	
‚#€dĞÜS R!L7Âà° †FC€ ª±…5ÎtV
$@r"lVÈ!Œ7¨	P ‚B±™EXV@r€l%ˆ
;€ @~(´ŒH"E"¤° Û°P‚"cT@*œ†°”OŒo 1# @ #  À1„‡ V$_e¤l„Ê"ÒÈK¬ärå¤ R‰ çB$D,CtBE'ÊˆQÈ0•ç`KÊa¢#§Ñ@š$h™tÁ!hF¨` ¥l°D€f(°ÈŒeJ@HøüI¸`	QH§@8 AÀ˜XQD€)b±`A‘B!Ïc8ØĞ$'=Ä¨
	!5TË¬3 € gA$H‡$BC	äV© S'0†"Ê Ò 
E0´"ÛŒQ ¸,©Qh0†”	XÄ^,@0 RF°	LdÈ™28Úp 0q²“äSá‡ƒààG.2Ô¡âˆA)I^,
0$!a ‹`‰†nhzÔÄagøÒ"	j)&,øÜIHIM”!EHBÄEtIHVº43Ã2R $€% €@’¯ƒ2e  ° ‘ˆaD0P‘v€1/Ñ!
!€N@ âQàKŒ$€  €º€€ˆ 1†4r  aH}Š ‚ƒG„ ˆ!Ã†ÂX€aU =‰¥H •È TÅ‚Mem „Ã5"›0^`^•GTQ‘Q“`	( ‚Fa¼ ˆúH0LÄ(4
. ÃÄ€Œ € «*DQÂAG} [HDà‘i¡¢± (@É…©š	ÉJBH™‚àŒ ØòÀSÃ“iÅ$êÅ˜:•Xäk'|Ğ±)! 9 ¤	Aà)"
 & @¢2ñ„‘° q€ @˜ÇH:Fr <B±&›]¨ °…@/ Ä(p$pˆ¤©°ò [b‹Í©`„iS2ŠD"<(…Œ ƒúƒŠŸ@ ÿ€c À¢@„Óf†@G
H^ ´£BE A @€¹jiû€,™©)$±Qˆ(²Et¡ÈÚä24Ç€i0„”€dA¦0À€BĞ‘ˆä¡pRN $€Ø
	/“Û T €	#€’LÈÕ›³QÔg"ÂqÓ ÜƒòNQÊ 0×DJ@*Mê ¼ Òà¥ÔÈ2Utş2l6°
Š $*0°©Àlp$(d8P™;ÄL+ "ÔNäKF„dâEH¶4X@$Ä*`îÇ Z`AåÙšÀ$¤Ê&¶‰WT@8èBL5I!ÌòYLµ€m¦JŞp@@mP€g€<(º8XÅ,±:’IQ¡B.2J…wB†¾ 1¦%Á†UÎD…ÍGB Ú…’Ä¬p4Ù O^ëñ²Q¶(Lğƒ% €p["-Ø‚>óªªl€À„`Pš‘‚0B‡2†#R ˜w0< †X4„Â†àÀbTŠÀ(L8@P i  ‘‰Ğ&‰Æ€Ò‚'P4¬‚R_Fzó ^@ğb0TĞ8Èã¢4%	4 €Aš ‘¥T 	‚µAªT"Ğp„
¸A ÔU
	:¯„ˆD.© †Vd’øõ M+±@‡NB™‹Š!H S )‹idn¥’ EQUHAïk P«}o¬Ìg¬ip	¡ÅdÜ ,€ ·R² ‚Æ8@Ğˆ r ”‰iÆ"Y“&Ãƒ(´Ÿ *) a ÙÊ|‘€,şrc€9Ì0é‰ÓB‚H*õƒŒ¯W_pSl ( AÂ¡ Óà0ˆïïNXB$ûp@¼ Â çl¨-H‚\à„‚\AˆO0¢M¤ŠF„Jš	 „1§F…Ò‘ lÚ°D
Bh€¥~{õT¹ü„@2µğŞ= ñ@RUR•²`DBâ¦ Àæ…Ÿ’…,AÔN±<»\Ÿ€¥­ãI’\%x=•ÇH5#`‚P¹†Wò¥@¬.“6d	²á“A² j!§`aáê²ë%T & ¡Éh%BFˆ!ó6'ˆ!‰0YİBD[ pbà `ab A’ H8ØM€	€ÕcK‘@:2I XÂ º½H$¢‘  €|$ØH¦ m $†Ğ*((%)é/JõP
 ˆ‰  ƒ5ˆ#¡’ƒ0‹Ø¡ Ğ À+2 ¸ `LC BKPZŒ@QvB¡AŸ%…^ 9Rƒ £2ÈÁ‚´a2nÎJT²Ç{‚RLO T( ¸)š5Š¼À•¦T…4t$	Œ#4Gˆ)Ãºb¶ n¦¬rj„°¨uP—˜–^ÀckğPŠğ@`.0¬Ö…@˜ QŠ(Ê J(˜dH$A
PĞdcJš†C„‚`% àĞ$Ujp(‹$C  A Â€ üˆÔÀ É"aa·!d„"Ã5È‰> 0Y1y&¦[G	hË
@H"„y­†!›Îé@dCŞÕ€~   € #Ó		òP`Q… P@IA%]!!@4˜(D]©.±à˜DG •hTØdŒ„¹Aà® ‹6$­À•’1šôŠÈ'Ù@óÓ‚€™
@DÏ€"ş‘È; ƒ	¦4¦6cv1lA;Ás¢Üé-  ğRha³¤Qêd	²@(^’U‚€‰Åq5H‘9tÌ"µÉ‡ÄpBàB	t èPÙ&4š#K‡QÀ¹ Â H0¶|Å1
¸lğca»$SE`ˆI ïD M6# <THHˆND 
&òI
  ª –MRnƒ 6‰ =Q‰0ÁU("¢úÍ‘`$4$Ğ‰@…( |óÇ€¡Á$!á#A79%•AQA \Øb.¡@È(‚÷£ y ‹¹ImĞO€…™á €è%†C*Ø6Ğ!™!‘if €‰LÀ…€ª
$Z9 ;‡a—¨†ôA€UAacŠ¼äOADÄ·kS¢
Ö%Ì@$5 Gs8ğ= Ì‹U›,¨ f  iDE8I$pc $Q“h}:0†€@¦  9ˆ8W¬# 2M ê@*TÄ~ÎhZ0w=l-€EÌ©2%Ş"°L@×Äè ¢5`€²\l$ ¢ñhÑQqÕ ÛZ™q 7¢i@ñ§°%§ÁZ‰„2a.`¨
ÁP°%+`Å ]ª(*ˆ©UA ¦G Ğ˜# ZQ•Ê
K %@¼  @  [10C…m6‚$ 0ùCŠ
âàŠ`Ú‘ Œ±GAE„U9iÒxC‘¢ °B  ` i ƒeB–@D!#/€Â ğ†l(ĞBÈ–zjñ€tÅpI•!LŠX‹ˆÒ…5Œ2³£‹À&Ì4Æ3‘•¬aÊH™Ø>’ßU*17ˆI$@[‘ÙÓ‚™@I¤±ì2H‹”YÔ0¡5	%IF˜’`±Š "/µàÉÛH8ˆ¶
•€‚M‰ì60‰)`2€äˆÕHD«Ô Æ¢ÌAÂƒ	h¢€•Q 0¥R("
há’8   ±ª@,Ğ@ª¹ Â ‘`”F
DÀ)$Š &ƒ(„ 00ˆ@Ure§HGX‹b«ˆƒDDqÈ:œ€° cÀ‚  HR1(ˆ„ SùB2ìÒj€@r€ñ%$Iì ‰
²F ÀyñÄ²S0HB,=$DbĞ”"(Ê(
JÁH ¤Ã€™ ££Á”ø  i$³Bp81RI+AdØl.‡³‚nJğ5²è€HH@	Bô¸P  ˆ
„Û…!Ôı„Ú4ÇÈF‚$z@€‚“}2„0‚Ğ‚M€QF€lC@–Š&ØDt €S	zZâawê™½CI €J(³À!0ti*“‰	ÈoË„@ †% Ğ"‡P-À+0€DÔ¢#V ÀAˆBh’Pƒ D‡Š53(ˆ©ÈYRÈ `„@0 œ> ZTˆ0ÀŠ xr¤œÈ	š¤¡  pŒ ‚ÎH èBHŒÅ (Yš!ji–T	 ‡ÌIE<&‘ QR! #@ßb&¾H3¼¥ò„'  0"  €8 Ò}H7 Ì˜«0"e({pMp`º)kc0…6ƒ:1„ga`1š„i‰ÖÀ¬„Å	äÌ‘°À ¦Hòˆ9’V 	HiA•¦±J† Tş‘ØÀ L¢R&ƒ4& †4¤cÜ	F C2$ÆĞu-LŞ® Xße"’`"*H†zÄ– #€˜¨BH®}ÂÆ ş@±  Á;LP$ 1Ñı	™Q„&F T‚AÂÒCˆ(7×İM‰‰- %"Y‡ÆI Byp’ “a,À!AG„,I$ÒØ‘  `4,ˆ\Ğ€œ®@éšHƒ€ BBH¹¥•´ˆ¯@0dP (˜A@ãRàÀ F  JH€; \À
@( ˆŒSè–H'4‡vˆ«ÁAF°"ÅAa0K q2†€c éP&HJ>0’p8Z Œd(àJk !"ÏDäş\+ğ±1d”QAƒá	Ç#û("D@‰p%	@#@…È›‚aª!‘AMŠ]"É"HÙ <ÒÁƒh D”Q†ŠD °)” 54 Ná 1Mjª(
€a ¨
It €ğ‚\ÂJ% `Ğ†O0‘& Uw §@ H„l	@8ÀQ¦Je˜B¨VH¨0€†QT#A…\ô	 ¨8l ¢CR¨Hˆ (R@(zZ@aƒ Cd™<%I„	` ®  Ğ® …”U@!›àæ»#@Q0h¥AfLÔ‰ )„R)FY2!ËpâFÀ(A€#(‡¡¡0-á)šHNh6C@@Å”ÆÑ€³AA €ì"¼ƒ` ¬‚ƒÃ`Â‰dŞò5¡"pÒóN@WØO¶  I2›@(#FfA#@©!XtUMP. gr åÕbB$l ¹= ‚ÁrV}`ßX[WAàA0‹æe„0³Å1t ‹Û°q.h%(`Tõ	¡PÄPÏ \”‘ĞºÑN(DÁ ª
‚+ dApPĞ F… ´%‹ˆ~ N \Yy`‚DThn˜!àA$$$Y ‚\Øa)'@Ä@ˆ
aB(H@b</@€†@$È@PÒ°E€€$³!ˆM6"rœÒàÈ@(K$…—ğ3ôp PH,¡"Q.xÄÂ4 A&ˆ0†ÁI” O ‚°–pyÛŞV“~‰„üÔ„&L¸$Ñ?À†ã³4dC²b!
‡0Á‘‡
Q…:`—	8ø`p´*R'ˆ­+e”¶Nw¨”€R,½_ŠåÒ@Äğ–Úc† ÒÒ#ÁN  ğÜa*`Œ" âGNJÁ>ØD]Ğ2áT@'G2+´ E@À0#YdAÎé2N0:äÂ &)à!' £~R„•  ñ]¬LªÄ”¬ŒHyd 	(„ëÌ$Â†DàÀq°
05pã’r' (2( à¤¨[) 	Dc+â¬P+‘ÈÄÂ,Œ£ —Æbd,ğ@&†œ1¡ Ï"†K…2Ed"OfôR„‚² *C ˆ¨˜ (‰)Æˆğ ß`Œ‚­@D†…ÎìQ
8/M÷L8aB‡—	Õ‡®`c#YA¥ …R1 ¬' ØB
 PsÛà(2è,œòËi’%>PÂ›š‘‚,’BÂ©ÉP¬ĞmJğ ¢L@0œ’ÆÈ¸A¡„G†¿$¾GÒÈŠiÁ‰É·€0‚¦ Ï €AŠ$4 0AË±¼A d DP„ºD1D¢	008)` %>(!,D¨\Z(„Tf B8¤™@#Ğˆ¨æMˆ¨`åBBP(ªDRÉ, œîÜÔØc¼A`0&¬–ƒZ QŒCP¬š€!© £¶0€i<wú ƒ] f  ÍHŒ 
âDT‘©7Š	06:˜è)" 9˜ˆœ¢²0° D˜šPkX¥P2r˜àmnğ9rŒRD¸ a”ì
	D†$I „@±¢H'êRœm„`Êæâ
Á‡N”r¢Äu@£‚¨,qEREQ@€>CÅ^I€ÛaÒi‘„ào“J¸–X†Ñ˜uLŸ‘
`!A–¤ p @ B"DøÉuz$hR	s Ğ@ ±¾xRB$¸É¥¤@À,MTlacement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" â€” or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure @ ,“æ„ADP)––Æ$€… ‡Ë€ÊA ƒT	ÜEø%ÉÁJ^e  ^èZÉTšˆv à@
ÀŠSˆ¶:0”Ğ)YCC ¡)ŠC* ¤0°V†$À	ØÚ9n9ôP-h€¦`TXfÙ Ù„JhÇSà€T%®U¸—>E$› ¤¥Œ ŒZr içº$B{è€C ä.Á’Ä²æŠ€a¼SoPL¸à<0BºƒX×ĞGê¤£QšÒ¢ C¨‚ÄXI\ˆV
Rö	ê4 ¥jÌÒÑtb©K8˜8ÄÀĞ‚Áp! \ NÄ‹àI)¨"C$*
DÚË~b€¤ˆD2—$Aª fÅ]ø§'ˆpÕ0€† GØkNåÀîb	DCqeRÈ`ÍÓ lÜâ9w¬Dop6!I­e‚›.'5?³B±Å#a¯H n.`Y^2™Hp+TÉ€Ö¢)b0„d´p˜Ø„5½ñ#òˆdz3P@D€D_B¨ã
’ƒ€@Êa\C0+(Ô)€F#¨ôg˜ˆgUÅÈLac[º
ƒr‰ œE$Êg˜0NÀB	L°\ÀÑ¤$¤OÓPê˜1îÁ ÁHªÔª )·Q˜` D€BAH„êÄL’Ä† ŒÃBÂ.Õ4Q˜t¤'r !Á'l`V†JiW”±/a¡4–‘¶ˆ]á‰T—€BU"ÁÎ@}ÈĞ&ilŠË•ODÄ’ˆX{Dí $1¢  *@Á@XD¡]ˆÕ†QKfPwH`*ƒ¨¯  ) ©¶ µB Ì˜tÀ»xl@¦„R  X˜— H³U%
4S¢M$
€p¢ñaAêçÈ
â*¢ÙÎZ4dA	DTAÁŒæÑ[@%H¬d'Å)ÈI‚}Ü( T °rMP, ¡,¨´ÅX	Æƒ’ J@`€0‰è©É(ã‰ts ’2‚É0' bá%È@Å'â(ø"‘Dš2	,Ñƒà
‰A¤% ™	'¤F!€#:43  •6< ƒÑê€§Bø†	PHùaŠÁÁ‘ 54b¾jÂ@À¢¶#h@f¡=À@iÁ’@		˜D!	‘dPÈÀÔD B‚aPÂI+cJ"JN*´z	‚‚
uS‚P% PğÀ
XQ0\pĞm2ŞZ A€÷àF°M@!à@
¸âÈ8,¸? °  (µ ³qI`…Z`à€(DwĞPH %` €„i‚B`j A"ÅQ  H1 +À¡(šÎô:„ÆÀ D@–X)fÂH¾ q€A,Åe@$
 J@„  C*A"ä
	0hM ¦@‚R j‚– Œ&|¢´Ä2E„&C2Ç„&¸nA<4’Ô,Á#x‚šS	À$YƒAA“@H.Bè@"‹Œ%IÊR d°˜Ì„‹L A™p\©ÒGˆ¡H ±…†8€@€‰&4Æˆ¤¨ÅŠ?†*^ÀÔlí—R ˆ%âèGAÅm‰	äˆ2¤€A¥#6 „Î%¡¡4´è
Àe41–L Ì"ğ,à‚YÂİĞRğ7ä`# ¨— B’€3	 Tàn¥$ ¶àqAhÂ*CJš	 I d«Ã˜!"U­Ø!c‰X. `¡!à€òAZ b`“()@\Á"9ğBb Cé„€Œ>$5HÁE‚¡ÄB ="|# ‚ ÍLº¬ @ü„@CtÖr…èa‰ÈpÊª‡,…š 5Ğdàš†	…D 
27änÀ«ÁCX–@È E†	+é,"
&L¡àÄÈDG Ñjéöà,ÜC6b‘ŒbÑ J…2RT€†	€è„ˆ4Ht"ÀQŠ¨ÄIĞ[`L,áJç¾—0&lE€B€‘AP0	*‚1çœi 0$«B¨…… ±ˆi|"E!Á¨\Q€ÀúŒ!æ@ˆ WF
‘û0e pc†çbˆ0U4^ ÉËq
DİcqA!<‚Ié
r:à9t“& [y$A8¯A@è$¸ ËÊ:˜Ê$Q%*©@@?“"ÂMÌ8<@M ú(³Q´ 
	XĞ*ª’rÃÊ" €•İ(üÄBÄiÖ=Ç‹pã5#
“ƒhT>E‚|µ8 9T2Â²„D=2q%  @½ˆ ‘«¨Ì@—‘ fcb$(GˆH*• GˆÑ€ Z‚eˆ£hƒ ˆ$‹ '¿NT+Ó‚  Çáf’v1 €¤»URPA@ÀëD9@İŞcI2¢A0h@³ªCÀ2¨6È
Ş
~p 
ŠáíÀ}ÔL¢Èö8‡Ï aè2K¾!§LP˜À(ÛPƒD@‹Œq‚CTĞš	E ¥04F$8l€ÒBP Š¥¦† Ã-f@QJÄ€§»°AÍ*’„Ù¶Xê´®Î0! ˆˆÀŠÊ  hxÃ$ğ@€_‚ä[±Ê
à2iA±”°Š™ †Æ@èÌâ‘”N"
Ò‡AWy‰Ä‚pf£ 0$ !¨
¡` 9° HzĞÑüI”Z``"d?:© ‹4‹N Ğu$°3`0•A€&JRÂ@ E6E* ¥*+
,
Ez@0TA	‰–‡L­„M"èG‚T•0&i|	a'ğ€Y@Õ
°( ’ D- .GÂ“ Ø$ôH@™¬ ¤
gÙ;dæb˜Œ}P)X•em‘Â! Iâ	¡ÒzB6„4ğ À¡à)B „Ğ@GNQm†DT]UZ€"Ğ€ÑHdFè”¦‹ `Pm¸9÷9L0Š¥¹AR  Ô-ô„ÓVf ‚vXbÑaD#[’`Ø£ X" À
j U	Ä@á	¦›Y‚&A IBHH!PU.D°	®¡”CÅ‰ÀÊ A²É”ÒhFpƒ ´	‚”	&BjÀÈÁ0' %à'‘S;¶Ğ ”UœŒ@"“¹Q4H  D”€¦L† 2|TSñ1˜Ép€†£‚Ğ‚^ˆ$ ’G	‚†ÁÓˆ˜@Ğ4LC01HSæ–-
 á – d,°#Ë,r€‹2‰ÊŒ0¨D@TPab•‚I 
ÇæÀBLº¤T ClO
EQ­ßX‚B	Š¡ El´ˆÃƒfˆ( H6ÄQ4Ê…6“‘=X¡YÂ 5(<Áa†Ü7$ì 1P¸Ò@€&:¶^@ä*Ø 2°.~
¿q—T€Ğ	@Nà@|4!@Dƒ˜EÁ $,’ B
Ô 'TsN
HW¥‹‰0	0#ÑÃø@ÀIARÅFÈ AhB {ÁŒĞ ¥	
¨‰Ji#€(ˆ1„$ˆM"3B¤Ia„o J4ÏuB
‹„Ø.°Ä Â‚#@…¬
!€L˜"M   (´ Ğ6)0Ãˆ„ÚÙN‚È3‹”E ØÊ)$\*&DÃ#¬,ÍFé @ P	 Œ+ªj( ŒŠ|XÃ€™Ô ˆ  ,°âœ&$Bô":ITAÙí À -RKöÉæ" êH"¨P)¦@	9œkƒ:¢ B&0’À	\ˆfH‰%M\ ½H¥4­È 
«u ·@ÍH‚Âœ4 høŠ€dDğ$2ˆ5ÊÈğ(V’b n‹uhÒ±"æ ¹€|JËc´K%
#
K’Sñ)ƒ2Sbœ ²€KÂ†k ˜›|1$¼ l	$”‡B†œm£«% A†‡‚Ïf*@  ©”àH'0TDRÀ'B.€”AX QA#³(Á&U`T‚>zR¦OˆÄ`  B	¥„J‚r
°Dª$
 ˜Ñ.9JÚ@À€¥Šc@¥Î"jBb¦‡¡[€F@	)M”¸h©CfQĞDRˆ<‚‰èhbde„‘F<Àhúw0AçR€÷ØQt@U e€QL: ˆBÌƒuxÑ„Ö&e#PéûXg™ğƒ 			@àsÉ˜d˜…G“æˆ€´Ğ`ŠB D2x:°`ğø%‡
…€&K1’@#	á¬¤4â	 &Œ  Ò5¡e0 O° Åhİ¶` _l€LP'XJÅµ`”¢D"IĞ4Y (à)’E1Ã"	pôëEU ˆ$P ÄôB1 	,‹DƒcJ\VŞ¬h	 	!Â	"Ñà a˜A´@¸ø °’Å„A2ÈAšT@£¡˜Z ˆ
 ùÆ ’‹ Å Jj 8ŒaNCd«Xa!€6‘ tEA‰*êEª€CP¬å˜„DA “(4DºD8«H0†¦Ñ±€% ä‡ âC€DP°¬£ °á>E@	`P%«	¤|šO$Æ ¶V0$€`Pš¦%€!Îz ¥(¬"#F"X`Á	”àTl£ì&0GKà2J0ÎKàAh@T tM&ˆøÆà0‚äˆ„rPf	 Ô0IÈ
$P	—/B] á*3‰ìPBÕTÀƒL©ˆtG/˜N «	¤ °©pfµ!
ò (B¦&lb‰puAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

export default Popper;
//# sourceMappingURL=popper.js.map
