/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.3
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && parent.nodeName === 'HTML') {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Get the position of the given element, relative to its offset parent
 * @method
 * @memberof Popper.Utils
 * @param {Element} element
 * @return {Object} position - Coordinates of the element and its `scrollTop`
 */
function getOffsetRect(element) {
  var elementRect = void 0;
  if (element.nodeName === 'HTML') {
    var _getWindowSizes = getWindowSizes(),
        width = _getWindowSizes.width,
        height = _getWindowSizes.height;

    elementRect = {
      width: width,
      height: height,
      left: 0,
      top: 0
    };
  } else {
    elementRect = {
      width: element.offsetWidth,
      height: element.offsetHeight,
      left: element.offsetLeft,
      top: element.offsetTop
    };
  }

  // position
  return getClientRect(elementRect);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var seco(­à± oc €!¡êè©I¨8á@€ ƒSkJÄ 	ƒ3êoÌ <—@ x!`€oR$Mú¨0Pdˆ ÀHVÌa¼Ì— %¢:ÑCT%5B˜&DÉ™hdB\ŠÀEC$FÀ6H07ÂAóB‚°À"‰“	»ê’m¸B¸LWW CÊ àyGHØ ÀÍÑÃãa¤amĞwpJtÊı‚!€–Á „ğñ•eÊÖ% xƒ¸¦
¤/rÉ9S°¨-•‚ä:4ÁI@¶Q@|I^€t€FvÁs¥ñ‘1slØP	8ÂV¢… …Ñ "¨¯rgo.š:oì'¡…!/ŠÌ`bdg…cHM'
€À˜~RÌcFPòêËğ’‰‚µ$AatrP
 P–èŒÈØ¸EĞFU‹ ˜Á€‹a4€4$,D–ô  Àì8À,€Ä% ùbÀ…
¨G9ĞP€C¹Ø(sàd
&; #e)Î
ØC@  ¤T` ƒCª’lA"B€€,!R2&B€	 JQˆ€ä <°€PQ¢È ¡Ä8×!¿æuXĞ` †Ö ²,”¡©5²¨Œ<d3;- W° † Ùbœ5êzˆ«Ô N•+APŒ2†Ät(‡¬k%•@¢»€3¬cÁK²sŒÈ { -ŒLğs‰IÔH(KLé€²©”Š˜V‚‚adb” u[Ò†d°a@(Œ”A' làA†B@ò" €(B&¦c@Å€ ’t@( "Fc œ`È 6 ìˆ˜ Ã¼T#ïP… ÈÒà¼ Æ!(€¡pH DA¬ 1JQ±‘qÓïX… Ø«f  0ÒJ‚Ö•0 ‘¢\˜ EHXBëğÈ Bâ"(¢$¢nB(=R 3°':	˜‰* 7Úˆ ä)	„ƒìX ÀwÕ +D„:”Š	’ºÂ€På4ÍÀ0‚0€Ö¡( (“øtA ì8¯ @$F¼k`	Å¡L¡„Uu™Í6L`ô×üÍ« ¤cuM¤Q
×<@ÖBM–dSÀMB”á–LÀt{3?XRÌ”"ˆplOĞ#|¬ @‚8@`³AƒÍ
(‡!!H
¼7R"Ä‚DŠ X"§6P5Hxq“  `ÁJ  
10§ë…
kÀ š’P	E¨4³i@à±D}’¸Ix¾dMä
Z  ¨ÒN 
Jb Š"¶³„`,D0Dà–”`lE–„˜„ ¡ P  	a*8’&m#_ÅˆÛ-œ"0NˆV-,%F À(`³ÎŒ4ÎÁ4Ä†T±DF0Ìé°‚C‡¢CIY8&2$AC’@r‚Q5³„AĞxC@!Pt±&€ÁP AÀç”OXä+Å`D¥h+ …/˜ÀÚˆa”	Á
fP4õŸ"„*y °¥S	„’†=FğAZb3yPC1Äè*Pš¨Ğj dÍï‰î¤÷‹ î0˜İÕ˜zR™²‚V Àyÿ;­A´¡Óƒ#ÈXÚ\ÀV yf˜˜L’K|XßIÙ›¸9@5@±r (ÑŒ Oµ
„BñĞ,ââ&M¨¦rÅˆA”€ï`@É<*Êô€ @¡€”æ1C%f© €	àDÑ œ@¢x#ˆ"ƒ `¨ X*áJ(’è8…È r
°2„¡Æ¼„A@ ]D	„òN„§è¯÷'š À*A)× Ä ¡ÆRi‰‘Rè ›D bœR`ÂĞ:î# 7‚Ò@Ğl†’l(83ì	€x	ğ”F‹y	¦4 ª!ˆpDŒĞPDt`€¶DRQB„"IBH=t# a[!ä ’TP”$0‚H$`2M:A¸'!®ÑP	P ¡˜+’–ä Ã0£Q˜²ØXˆ ê,!t
­!A„ 0#¨ Â€Khâ8d¾Õ¤ÃìÄì@6¤ÄeH1Y€æ5BÛ|1©°’%IŠ%!J$p©$’ Àƒ
Da¾  
€$ lE†Æ:h€@FØ": ° ¨ ˆT’ˆBŠ[ šP ‚ R„Bë§¤¥ra2š‰X	%(Â :X ˆàBÃ6c Ê2&Ğ›&‘Sm“ÍÀpnL¤Œ#cYH
ô‘C Ì2aôVR'EfÚToÖ2 Áa©CŒxà‚Í‚Ÿ ‘
ìCQC"	ˆqEO¸ÅfAQ"–9 
Gv–c@T‘,B‡À	ìO2J”p¢ÀM/ i ˆ@ˆdÎe+ˆ9BÉÀ}®£0 ±œˆ ¦§Ôˆ'0LšàEH< Q€ƒÙ8Š"x JpKr@ wH BŒ1ACDÃ">¬
 Ò 
'(PØÈƒDœRATd€‚€¤ˆêK@ §µ¾ d¸ J’*„„èÔ$ËÅ¤ª9„$¥@s, Ãª¼K¥­$£‚`.Q»#G„  ± M¦m°PIŒStTÔ³ DU4¢Wh@Æl5y°QæZÓLÒçˆ°~èÑ%Û©÷›ä{0P¼€°0`@ø/°l¤&p…˜ejÒ¥bˆœ ªÀ‚HQ@siqW*¢ÂÒ"ZõNŞL3õ…OH‚ AI)ĞCëòš. ‘C‰£œCd	(u>"„œ
ãQöL$KRP„$‡£D%ÿØ^2 ‚8LRPY8Œ§$°QC¸
¡…y>e*’ •-CÄ€W¡Ä  `p¨B`Ğ1@FP  5ƒH-2@',%„|(a†’A€¸ €RT@ÈBÈ !,Êa€@#hIÖ&ˆÙB€Ç@r:!È : $PBˆG	b¡òKT”,04A9"  ²‘¸“œNd  )Ì@¨¬dòÁJ@Å˜¢DúqS ô˜å`€0H
Í8¦dpB@l‚
!@’uCG!@sŠ ŒØ¨èA ¬P’'X6 HÒO‘Æ½¤öRÀ#@´:ÛÅy…PÑ#D­„4	NH iÎ¥‰Î`”  `v¥ ^„ÜAˆi ”P hA	 ÂÌ`QrG‰ ‘Jü B±Bgb%]9Ê" #  U E;I
A
Ø ™ x]Q *-ºaä€eJ„A B	Ái`H œÙ.Ca€ˆÂx#Jh@Œ<©`gpv>Ôƒ xâ ‚0-Éh@c Ğ‹"I€…ˆ ˆ—Z€n¨@¤+Èx#$’°†
I)FáÀ€†äÇx  áŸË;¤bjà
¨P¹  `-Š8 h¹PEŒmIEXˆQD„ É¡åÃm¬"ŒB"Bƒ&Pš%m°YanKA V5 Ä¸WhõØ)l cŒĞq½‰Œ.<0A²8ª Ó”„R­è«EHˆB»P*R Pƒ”jE…B gû ,:E*Q¸Q¨çÆH%@f$Bn”OÅ@±Zd³„!i"˜H$¸^èiq¸ˆ"8€@EnÁ% CP HuÔˆ@D‚#h¢&b(DhTÒ€‚B4£ˆZ¤Ë K	, `   ‰”@ &ağ‰¸Îã@  äğ ‰€] t@SBÌ $JIxœÄLg dˆÔ¥
—F¡¨åDbÅ8dØŠˆ‹3xÏp™A3y¤ ¥
¤Èm­€Ct ,„DÀ ÈPàà1ª50àÍ‘B°2ÁÑVBäb1h¢‰ˆeW'‘Œ5p$ Dxˆ°l@  MøFÆ›<éÔ¶"Ã`7Ê€$¤Ş‚ˆ €Ê&øT·I’
P´@Y‘&Ô“(0Àõ¦ÃTr'Ç1Qí1À "ê€§l`@%‘*øe€X4Õ ,BÀ8ƒN"£"0tM„ Ø¡:ÀO…P:˜VÀrd‚Â0‹Ñ#êHÉ„e@‚‚³¤A Ğ¢ @@§"U¨P  £ûˆ8E„qE†;¼Œ1,GiÏ‚Aà8ÃbC˜"E ZÀ
À€ø N	@L)’WP€T©jD¨‚êHr\"€,‘½!gpOiÖ8È@V%„’Ëh$ƒäÒ+"€QÅ¢@›BU`¢3ôJƒSS…C±:ÂáÃLÂ“ 1'Œ›DônÛµ‚ÑB}QTj–b™@=hËz WMÕXC!TFKH2‘ÉÂ""µMDœáE¸’È„#"š«ô‹ñ$ä"!‘ É ˆ>(Ğ*Ã¾ $:0cdD/Œ@†
2
ˆLˆA–@D €10²`Td¬IĞÀ¢¤@B $‰À@iğa6 J#É$.òx 6”%á¡V‚„I‚°Œ …@Ä’	Â °‘@é Õ\ J˜pW¥	+`a©Db, Ap|Â@$@9â|&Á°†Ñ"@’j $D‘ 6…@ŠH€0è@l *	‘  4 x’€Xp €‘ Ğ¤|’–A:À „$ÀY¬À,È€ Ô@    €Š‚n .uF$ (0©r]cÊ4œà dĞ­ Ó@Sˆf@‘5MG`¿°øÏEF?4×l±²ñHàh° j;µI˜€>I'`¿ˆ„. )Ã! ƒQ£ƒ„; jÀˆèJxEÉˆ>k®¼O²'Zæ(wb¢B%0B§B0ÀeA@„ôP`R\ŞÀD‘ØQ —hÂÔèšĞ”%<X[0‡†)5 e¶ÀÑ³Z±‚²  HÅe¼
¬X#2¥ÒZ/‘"·[µ Åà7>!á ”ÌdQ2 T¢ÕN1Ğ B6ÄC (‚"2L H #/¢‚`#’‹Š)<€´„cA‚PÁz€@Bîû@€ Ä<•!€G%úÑ	~!”!ÓÂÅB
KØFAd¨FM
  X¤NPÀ „©@0F!†ĞDp…FÌúò6N‚Á*0Ä¢À"R 2‚ÈšH†$@‚ vã0,…&”À¨á¢„ØAâFE uÃ X(ˆÉ>Db@Ä—€5J   Ä"BË1  @‰^8Â‚:¢*ÀÙ …% TU  2ˆ  !
‰@S ­²cB9ğc@º2] ± ‰xĞŸ7ôĞÌ¼DQä'Dœ8R%@”0¥Ì•ÿ_ô6S#„Hê€c|`q&VÑaBË Uç£`†ÌZe0
1xÈ]$t †­„»…ÙH¡ia†/K(æ_Š.Z‡ &C2¡ÈŒZ,2 
ˆª¡12ƒ ( ƒ¡é@d†€/Ìi‘XÂˆ†(M 8Eà&@
	™…H!­:B `H@qE(RX¨‚
¢ÉBˆ  9ZAD8ˆ/A0…âÅB¢– Ùk°$¹Œ n F˜¡1!M8ÏÄ¼N6`’MJN­C :/°Q†“çµĞĞŒ¡ù*Äc ™a¡„Â   ˜9SÑÙ  0”hNZA%‡DpLÒ $Ÿ ƒÕ“•éz`â²Û0 ¤µDS³u`9ğZ ‰Sb…c°¹%R 5#? @ŒYQ]„êEôÁàˆ6¦Â(…Öàm Õ`46ê
%D‰ÒÀB ^EØ‡,js­*ƒ€PR€OX#”O'ŠjQ€ ™¢ÈI4 ‘·¬,‘  ˜Qœ%C«ÄWÇ€¸Œ Û:ˆrœFá´ê0a¦Àc@êFÔ$¦'@-`A- D eˆ " 1‡%‘ìBÀ¦æ	‘¢!JBhr„D 4àxH`0†£@"âŠ@X 1Ä 3`¦
$¤È*3a¸S$%œ…T` °0VZÌV„F€|J €„p0è"Á «Ä@BÜ©åL²Pã	JPf® aìÌ`yB4ì¦DÁ2B8–‘¤d!;CĞjú:"*,)òäcJĞ $‚`¤Íƒ>…aKÍÓ`8ÀEHA`ÂE*‰}3<€–Jª„„„€ËĞrT€G@XôœÈØ
îx8C¤JÒ*‚Ò€Ğà	‚ bM((F€jJ1Š>ˆ	É  ˜ñ¯€8 )H¡  I¨ `4SˆA Ô@a”( EÓQHa¨‰€´ü0¬ „ €(ƒ_À $@R @¸€%-B(d L  àu@¨c@ŠsXC@„„ø€°&@ B2 "ˆ €’äjbGÙ¨!b %ŞÁA|L1(!P€Á% ŒØ TÔT’$6PŒ˜² 4¬YhŒ 5 ÔŒ`¢aƒ¢AdÀ‘aPè xÁU† a%@vÈ ®dº‡àU1Ğ0Æd¨¸1Š!Ìc…Ü4–l{DI0Ps"3û¬dÀÇ2¬Í '@„„ø‹&­G-pUÈĞ4I@¨²€HîJ=m¸<xS$Y²DU3	¤*Æø@%C– "¶“Š!é…@Ğ	ÇÀ JÌÓ(dAE¨Ô›   i³P¡$c0CGªó€	JÈ¸  ¸Ö 1!ğ…j „  D'd5Êğ Ät&¢TL€¬  e't(vá]Ì%t“Œ„6Dæäçd	æ(LÁ0)¥â„‚(¬ øœÄ-D=Âl±È,IÙvM]Æ•$À±>XHˆ@€€‚ CG_õg¤R”¡A%ò¡4¸0èA¬$ˆ*@t»bŠÌpê‘'(È»ÙBÔ“`")ØzÁŒ:´»"Œd€7äET£T@»$‹ms‚Ã:1E]²$pÿ/r0Æ’= 7–ò@t ±@ ÖD É\õDŒXu»P$rİAÄÃØ”bvr‘VGº8ÉQ-F(rƒ(\”#sÅMR€1ET ±ÃBÄ¨)r$RÀyYÈ0;êaÆD•à„À|M®ã …4ˆã) dØD!ÎN}Õ€ ‚@xüÙB ‡ ’É¡…0AQA€m e2U8ˆ²	‰›2(&úFİ!C€Â€ ŠST €AB\ä#H„
eP (˜Æ$/$  @i\	qD(€\’‰° ^– CÁ ÂÃo " \4d³ø	Ì¨	Ód2Eç ²Ù´lAH½À’n²„)6MPY #EsØ¦b„B_Ğ„‰  ÖeÎ
R,¡¡-•ÂF(°—dV Tä…PFcˆËÉÄ@&í8…{ F
0] ´}„à	LBeš	¢ğ!0Ià…é!Œ $¸d(HÔ’l 6Bº
£8ÃØh ©O “ S
ˆ #¡”ŠTA•¢P±Œ»´¨ °#å»‚À@ (Ğ!@  ˜ˆH„Ú  ¦Bƒ E€Vn‹¬å )´7 †d¥0­ ªŠ‚ 19 KU„ò@DP ŒBP’@ BĞ À„:ÇRàbğÜ¢Cİ‹ b¨I ƒ µI E¨ $$ C€&ë$”À E‹/!i šø8‘ÌGA
Aæ‹D ØJqL"ˆ€	ƒl"ˆ 6+0/PÍ˜[0RhxÃ ­@d€Hˆ1Â ‰±O2M ˜ÍDJ^Ä©¨ DÀ§ ŒA&ˆ Í4Y#¶@ˆ ´pÑ6’ ¡B'eTpC¥*CE0`P=U¹„)a :4Â„&@ò)Çµy2
´Âd#¦š-p/=€"" „m’„&80äƒ=@€€Á¨€¤¥ëtAÑ"RÀœT©Ù  ­(B Á˜J%…±âÃ%Ğ&rj ¢dD„Ló‹¦ ¥‘!`(V¢‘…5H m.$.Ä
Â*be …P€F¡	”`€bj †ñGåœD‚8ÌŒ$Ş#0X#‘áÀ¨ÒÔ¤Ü£Ñ¢s*¨ëˆ(‘pßGCz”Ğw+¸i¨J¡„©î†ÒcRÁÈEV coÅ‚R ÔÂ@nÑEpflF€‘Œ1{YS6FA‰™œÒ{@B.hÂ™Éc	“AMğP%@:mĞPNOŒ%À LÕÕ4dk
1PUNj"C’ m	%WŠ0H F™†àIĞ `´‹:CEhÈU ÉJ%Ê|€(¢ñœZZ¦¨2ÑSÆ’A9ÁG gB ‰HEW «@P   Z9+'x #¤§I”¥   cV@  $  Á/J"„1K@”\  ª!‰A¬¤@Pà I 4€"¡ˆì@C,¦&à–TJ¨ P€2D@ ZÀ
 piRHÈ€@BK :‰`+mBÀ$LFi4”%¶xõ3%C±j|&pü²@˜B? ÅˆÌ\'À±	Á˜2 ŸÄ>@H%, Íœ¸ C³A ÅĞ‰Ó„Ãà7ƒL‘@el‘‘†±B¦!pŠH…' Vˆò¨(Ê^DNè‹5xB™@ä˜VÅ¨J‘†iÁ$Ht`ch€¤Æb€ rÊ÷°Œp¬Š€EÀ ƒÕÂf±*Õ}ÃÀi
°Q²g !uÌ&$‘§ğ$ "Š*”™1l˜¾ÁŠ\” C’Á¨ @ñ. )PÆJBA€,1"„N!2\a0qTXÒP @ffC@-•Âwp2˜B€ 
Ü•€ à) Ø+¢¥ €p¡$¨"—1h A²ƒ§Ä…!``
QĞ0­ ‚D1a¸"D² `+v ğH@t¦"8°â‰-‰‰Ô,Q†! …,••!JpX1k$?	 JÙH±¥9p!„€Z›Çj1…üA¤y0íGn!ƒR@ iµi !@ax9úõ Aı¬¢…ÛBkF8r dLH€‰À_¦Dlrc( åUPë'pq3M€OGHp€ÅÅŠVgñ„),Å !Ã$ Â’fhTãcAt,DĞC`_‹)$&€)„R° ŸàšÄp€E64¹rB Ì 0‡(< Á (ˆ¡E¤
‡ @©@b Œ´c¡-°``8r9P(4‘¬@‰ĞÓ Éhƒ‡  ]¡ˆ€‡Ú´„C§B¨)FˆéæA³…ng€ DaÒd  NaÊás~¾,ˆ–.YfÅ" Ë&5 @†gÑŠP‚ †0-2bA&ÖA%AÈC0-D½T†0‡Ğ)FDRËU@€`+B  ë/g80P0$
Ãä øfhNI-|ub
hhØD)"pÀá\#BL=¦:PÖ@šI	°Å° P@ºp<%’š0ÉDÁB Ãó!X Ä*ğR[„¨ºæiëv2€ßy*@ƒ@a$!gœÀ*
ÒjêÇà(áÄgÕJÿ FF@ÄX$NNEá%j@
 @ EÈ P* •€í€¶$"ˆˆ
„²  0¥Âİm0ÑI€€T  `3 M…	 0 Bl… CŒ†‚…øO¸
À¥ Xh”x0Â0D‘O6† €2(LDAB $jj lities using named exports, if you want them all use:
// ```
// import * as PopperUtils from 'popper-utils';
// ```
// The default export will be removed in the next major version.
var index = {
  computeAutoPlacement: computeAutoPlacement,
  debounce: debounce,
  findIndex: findIndex,
  getBordersSize: getBordersSize,
  getBoundaries: getBoundaries,
  getBoundingClientRect: getBoundingClientRect,
  getClientRect: getClientRect,
  getOffsetParent: getOffsetParent,
  getOffsetRect: getOffsetRect,
  getOffsetRectRelativeToArbitraryNode: getOffsetRectRelativeToArbitraryNode,
  getOuterSizes: getOuterSizes,
  getParentNode: getParentNode,
  getPopperOffsets: getPopperOffsets,
  getReferenceOffsets: getReferenceOffsets,
  getScroll: getScroll,
  getScrollParent: getScrollParent,
  getStyleComputedProperty: getStyleComputedProperty,
  getSupportedPropertyName: getSupportedPropertyName,
  getWindowSizes: getWindowSizes,
  isFixed: isFixed,
  isFunction: isFunction,
  isModifierEnabled: isModifierEnabled,
  isModifierRequired: isModifierRequired,
  isNumeric: isNumeric,
  removeEventListeners: removeEventListeners,
  runModifiers: runModifiers,
  setAttributes: setAttributes,
  setStyles: setStyles,
  setupEventListeners: setupEventListeners
};

export { computeAutoPlacement, debounce, findIndex, getBordersSize, getBoundaries, getBoundingClientRect, getClientRect, getOffsetParent, getOffsetRect, getOffsetRectRelativeToArbitraryNode, getOuterSizes, getParentNode, getPopperOffsets, getReferenceOffsets, getScroll, getScrollParent, getStyleComputedProperty, getSupportedPropertyName, getWindowSizes, isFixed, isFunction, isModifierEnabled, isModifierRequired, isNumeric, removeEventListeners, runModifiers, setAttributes, setStyles, setupEventListeners };
export default index;
//# sourceMappingURL=popper-utils.js.map
